# Python网络编程学习笔记

Abstract：本文是根据作者日常学习Python网络编程相关知识所作的笔记，主要目的是为了方便日常的工作学习，同时也希望可以为其他小伙伴带来一些帮助。

Author： Duguce

Email：zhgyqc@163.com

Datetime:  2022-03-06 22:45 —— 2022-03-07 23:04

## 1 UDP与TCP通信

### 1.1 网络通信概述

网络就是一种辅助双方或者多方能够连接在一起的工具，然后可以进行数据传输。所谓的网络编程就是，让在不同的电脑上的软件能够进行数据传递，即进程之间的通信。

使用网络的目的是为了连通多方然后进行通信用的，即把数据从一方传递给另外一方。为了让不同的电脑上运行的软件，之间可以互相传递数据，就需要借助网络的功能。

### 1.2  IP地址概述

**IP地址的概念**

IP地址是一种网络协议，用于标识连接到互联网的设备和计算机的地址。它是由32位二进制数字组成的数字序列，通常被分成四个数字段，并用点号分隔，每个数字段的值在0到255之间。例如，192.168.0.1就是一个常见的IP地址。

**IP地址的作用**

IP地址用于在互联网上找到其他设备和计算机。每个连接到互联网的设备都需要一个唯一的IP地址，这样它才能够与其他设备进行通信。使用IP地址，设备可以通过互联网向其他设备发送和接收数据，例如网页、电子邮件、音频和视频等。

**IP地址的分类**

在IP地址中，有两种类型的地址：IPv4和IPv6。IPv4是32位二进制数字，可以表示大约42亿个地址，而IPv6是128位二进制数字，可以表示更多的地址，以满足日益增长的互联网设备需求。

每一个IP地址包括两部分：**网络地址**和**主机地址**。网络地址指的是一个网络的标识符，而主机地址是该网络中每个设备或主机的标识符。在计算机网络中，网络地址用于标识特定的网络，而主机地址用于标识网络中的每个设备。网络地址和主机地址的长度和格式取决于所使用的IP地址版本。

在IPv4中，网络地址和主机地址分别占用IP地址的前几位和后几位。网络地址和主机地址的位数可以根据网络的规模和需求而变化。在IPv4中，网络地址通常由子网掩码来指定，子网掩码是一个32位的数字序列，用于确定哪些位是网络地址，哪些位是主机地址。

> 例如，如果一个IPv4地址为192.168.1.1，子网掩码为255.255.255.0，则前三个数字（192.168.1）是网络地址，最后一个数字（1）是主机地址。这意味着这个设备属于192.168.1这个网络，而1是该网络中的主机标识符。

在IPv6中，网络地址和主机地址的划分是不同的，它们都由一组16进制数字组成，由冒号分隔。

> 例如，如果一个IPv6地址为2001:0db8:85a3:0000:0000:8a2e:0370:7334，前缀长度为64，则前64个位（2001:0db8:85a3:0000）是网络地址，而最后64位（0000:8a2e:0370:7334）是主机地址。

IP地址被分为5个类别，分别是A类、B类、C类、D类和E类。每个类别的IP地址有不同的网络和主机地址的位数和分配方式。以下是每个类别的地址范围：

- A类地址范围：0.0.0.0 - 127.255.255.255
- B类地址范围：128.0.0.0 - 191.255.255.255
- C类地址范围：192.0.0.0 - 223.255.255.255
- D类地址范围：224.0.0.0 - 239.255.255.255
- E类地址范围：240.0.0.0 - 255.255.255.255

A类地址：A类地址的第一位始终为0，后面的7位为网络地址，剩余的24位为主机地址。A类地址通常用于大型网络，可以容纳大约16,777,214个主机。范围从1.0.0.0到126.255.255.255。

B类地址：B类地址的前两位始终为10，后面的14位为网络地址，剩余的16位为主机地址。B类地址通常用于中型网络，可以容纳大约65,534个主机。范围从128.0.0.0到191.255.255.255。

C类地址：C类地址的前三位始终为110，后面的21位为网络地址，剩余的8位为主机地址。C类地址通常用于小型网络，可以容纳大约254个主机。范围从192.0.0.0到223.255.255.255。

D类地址：D类地址的前四位始终为1110，后面的28位用于多播地址。D类地址用于多播（向多个主机发送数据），而不是点对点通信。范围从224.0.0.0到239.255.255.255。

E类地址：E类地址的前五位始终为11110，后面的27位保留。E类地址被保留，不用于一般的网络通信，而是用于实验和研究目的。范围从240.0.0.0到255.255.255.255。

这些IP地址类别的分配方式由Internet Assigned Numbers Authority（IANA）管理。

**掩码和广播地址**

**子网掩码**是一种用于确定IP地址中哪些位用于网络地址，哪些位用于主机地址的方法。子网掩码也是一个32位的二进制数，与IP地址进行逐位的“与”运算，可以得到该IP地址所属的网络地址。

例如，如果我们有一个IP地址为192.168.1.100，子网掩码为255.255.255.0的设备，通过将IP地址与子网掩码进行逐位“与”运算，可以得到该设备所属的网络地址为192.168.1.0。

**广播地址**是一种特殊的IP地址，用于将数据广播到同一网络上的所有设备。在IPv4中，广播地址的格式通常为某个网络地址后面所有主机位都为1的IP地址。例如，对于192.168.1.0/24网络，其广播地址为192.168.1.255。

需要注意的是，在一些特定的网络中，例如VLAN或者子网划分后的网络中，广播地址并不一定是网络地址后面所有位都为1的地址，而是在该网络中分配的特定广播地址。

**Linux中查看网关**

查看或配置网卡信息：`ifconfig`

测试远程主机连通性：`ping`

路由查看：`route -n`

### 1.3 端口

**端口的概念**

在计算机网络中，**端口（Port）**是一种用于区分不同网络应用程序或服务的数字标识符。一个端口可以被看做是一扇门，用于允许数据在计算机上的不同进程之间流通。计算机中的每个进程都有自己的唯一标识符，称为进程ID（PID），而端口则用于标识进程中的不同应用程序或服务。在Linux系统中，端口可以有65536个之多。操作系统为了统一管理，进行了编号，这就是端口号。

**端口号**

端口是通过端口号来标记的，**端口号**是一个16位的**整数**，它的范围是0到65535。其中，0到1023的端口号被称为“well-known”端口号，用于标识一些常用的网络服务，例如HTTP服务（端口号80）、FTP服务（端口号21）等。1024到49151的端口号被称为“registered”端口号，用于标识一些自定义的网络应用程序。49152到65535的端口号被称为“dynamic”端口号，用于临时分配给某个应用程序。

*注：端口数不一样的unix/linux系统，还可以手动修改*

**端口是如何分配的**

在计算机中，端口的分配是由操作系统进行管理的。当一个进程需要与其他进程通信时，它可以向操作系统请求分配一个未被占用的端口号。如果端口号已经被占用，则操作系统会拒绝分配该端口，并提示错误信息。

**知名端口**（Well-Known Ports）是众所周知的端口，范围从0到1023。它们已经被固定地分配给一些常用的网络服务，例如HTTP服务（端口号80）、FTP服务（端口号21）、ssh服务（端口号22）、https（端口号443）等。这些端口号是由Internet Assigned Numbers Authority (IANA)进行管理的，并且已经被广泛使用，因此应用程序需要按照约定使用这些端口号，以便网络中的其他设备能够正确识别和处理数据。

**注册端口**（Registered Ports），范围从1024到49151。它们可以被应用程序动态地分配和使用。在启动应用程序时，操作系统会为其分配一个未被占用的端口号。如果应用程序需要与其他进程通信，则它可以将自己的端口号告知其他进程，以便其他进程能够将数据发送到该端口。

**动态端口**（Dynamic Ports），范围从49152到65535。它们可以被操作系统分配给客户端程序使用。当一个客户端程序需要与远程服务器建立连接时，操作系统会为其分配一个未被占用的动态端口号，并在通信结束后释放该端口号。这种方式可以避免客户端程序使用已被其他应用程序占用的端口号，从而提高了应用程序的稳定性和可靠性。

**怎么查看端口**

查看端口状态：`netstat -an`

列出当前系统中正在使用TCP或UDP协议的2425端口的进程信息：`sudo lsof -i [tcp/udp]:2425`

查看哪一个进程使用了22端口：`sudo lsof -i tcp:22`

查看某个进程是否还在：`ps -elf |grep udp_server`

**端口的作用**

端口是为了实现网络通信而在计算机中开放的一组数字，用于区分不同的网络应用程序或服务。在TCP/IP协议中，每个应用程序或服务都可以被分配一个端口号，从而可以实现多个应用程序或服务在同一计算机上同时运行，互不干扰。具体作用如下：

- 区分不同应用程序或服务

每个应用程序或服务都可以被分配一个端口号，不同的端口号代表不同的应用程序或服务。例如，HTTP服务器默认使用80端口，FTP服务器默认使用21端口，SMTP服务器默认使用25端口等。

- 提供数据传输的入口

当数据包到达计算机时，需要通过端口号找到相应的应用程序或服务来处理数据。例如，当浏览器请求一个网页时，数据会通过80端口传输到计算机上运行的Web服务器，Web服务器接收到数据后再返回相应的网页数据。

- 实现多进程或多线程并发

端口号可以使多个应用程序或服务在同一计算机上同时运行，实现并发处理。例如，一个Web服务器可以在同一时间处理多个用户的请求，通过不同的端口号来区分不同的用户请求。

### 1.4 socket简介

**不同电脑上的进程之间如何通信？**

首先要解决的问题是如何唯一标识一个进程，否则通信无从谈起。在一台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。但其实TCP/IP协议已经帮我们解决了这个问题，网络层的“IP地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程。这样利用协议，IP地址，端口就可以标识主机中的应用进程了，网络中的进程通信就可以利用这个标志和其他进程进行交互。

- 进程是指运行的程序以及运行时用到的资源这个整体称之为进程；
- 进程间通信指的是：运行程序之间的数据共享。

**socket的概念**

socket（简称：套接字）是进程间通信的一种方式，它与其他进程间通信的一个主要不同在于，它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于socket来完成通信的。例如，浏览器、QQ聊天、收发email等。

**创建socket**

在Python中，使用socket模块的函数socket可以实现：

```python
import socket
socket.socket(AddressFamily, Type)
```

函数`socket.socket()`创建一个socket，该函数带有两个参数：

- AddressFamily：可以选择AF_INET（用于Internet进程间通信）或者AF_UNIX（用于同一台机器进程间通信），实际工作中常用AF_INET。
- Type：套接字类型，可以是SOCK_STREAM（流式套接字，主要用于TCP协议）或者SOCK_DGRAM（数据报套接字，主要用于UDP协议）。

注：套接字使用流程和文件的使用流程类似

- 创建套接字；
- 使用套接字收/发数据；
- 关闭套接字。

### 1.5 UDP简介

**UDP（User Datagram Protocol）**是一种无连接、无状态的传输层协议，它不像TCP那样提供可靠的数据传输和错误检测机制，而是提供了一种简单的数据传输机制，可以快速地发送数据包。UDP通信具有传输快速、开销小的优点，适用于对数据可靠性要求不高的场合，例如音视频数据传输、DNS查询等。

UDP通信的特点如下：

- 无连接：UDP不需要在数据传输前建立连接，数据包可以直接发送到目的地。
- 无状态：UDP不保存之前传输的数据包信息，每个数据包都是独立的，即使数据包丢失也不会对之前和之后的数据包产生影响。
- 快速：UDP没有TCP的重传机制和拥塞控制机制，因此传输速度快。
- 不可靠：UDP不提供数据传输的可靠性保证，数据包可能会丢失、重复、乱序等。
- 支持广播和多播：UDP支持将数据包发送给多个目的地，可以用于广播和多播通信。

UDP协议通信时，每个数据包都包含源端口和目的端口，用于标识数据包的发送方和接收方。**UDP没有连接建立和断开的过程**，因此数据包发送和接收的过程非常快速和简单。然而，由于UDP不提供可靠性保证，因此在实际应用中需要进行一些额外的机制设计，以保证数据传输的正确性和完整性。

<img src=".\images\UDP通信结构图.JPG" alt="UDP通信结构图" style="zoom: 50%;" />

<center>图1-1 UDP通信结构图</center>

如图1-1所示是UDP通信结构图，创建一个基于UDP的网络程序流程具体步骤如下：

- 创建客户端套接字；
- 发送/接收数据；
- 关闭套接字。

下面是Python中使用UDP协议实现服务器端和客户端的代码简述。

- 服务器端

```python
import socket

# 创建UDP socket对象
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 绑定IP地址和端口号
server_address = ('', 2000)
server_socket.bind(server_address)

while True:
    # 接收数据
    data, client_address = server_socket.recvfrom(1024)

    # 处理数据
    processed_data = process_data(data.decode('utf-8'))

    # 发送响应数据
    server_socket.sendto(processed_data, client_address)
```

- 客户端

```python
import socket

# 创建UDP套接字
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 目标服务器地址和端口号
server_address = ('localhost', 2000)

# 发送数据
message = 'Hello, server!'
client_socket.sendto(message.encode('utf-8'), server_address)

# 接收响应数据
response, server_address = client_socket.recvfrom(1024)
print(f"Received response: {response.decode('utf-8')}")

# 关闭UDP套接字
client_socket.close()
```

- 一个UDP网络程序，可以不绑定，此时操作系统会随机分配一个端口，如果重新运行此程序端口可能会发送变化；
- 一个UDP网络程序，也可以绑定信息（IP地址，端口号），如果绑定成功，那么操作系统用这个端口号来进行区别收到的网络数据是否此进程。

**发生端口占用怎么办？**

1. `ps -elf`查看进程
2. `kill -9 进程id`

**UDP发送数据的特点**

`sendto()`一次，内核里边放了一个队列节点，`recvfrom()`就拿一个节点，拿的时候内核就删除了，`recvfrom()`的大小要大于`sendto()`发送的报文大小，否则在获取时就会丢失（Windows是报异常）。

### 1.6 TCP简介

**TCP (Transmission Control Protocol)**是一种常用的互联网传输协议，它是互联网协议栈中的一部分，用于在网络中传输数据。TCP是一种面向连接的协议，它提供可靠的、有序的、基于字节流的数据传输服务，适用于各种不同类型的应用程序。

TCP通过建立连接、传输数据和断开连接三个步骤来进行通信。在建立连接时，TCP使用**三次握手**的方式进行，确保双方都能够正常收发数据。在传输数据时，TCP将数据划分为若干个数据段，并对每个数据段进行编号和校验，以保证数据的可靠性和有序性。在断开连接时，TCP使用**四次握手**的方式进行，以确保数据传输的完整性。

TCP协议广泛应用于各种不同类型的应用程序，例如网页浏览、文件传输、电子邮件、远程登录等等。TCP协议是一个非常重要的互联网协议，它的可靠性和稳定性为各种网络应用程序的正常运行提供了保障。

**TCP的特点**

- **面向连接**。通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。双方间的数据传输都可以通过这个连接进行。完成数据交换后，双方必须断开此链接，以释放系统资源。这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序需使用UDP协议。
- **可靠传输**。
  - **TCP采用发送应答机制**。TCP发送的每一个报文段都必须得到接收方的应答才能认为收到方的应答才能认为这个TCP报文段传输成功，每一个报文都有一个序列号。
  - **超时重传**。发送端发出一个报文段之后就启动定时器，如果在定时时间内每一收到应答就重新发送这个报文段。TCP为了不发生丢包，就给每一个包一个序列号，同时序列号也保证了传送到接收端实体的包的按序接受。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。
- **错误校验**。TCP用一个校验和函数来检验数据是否有错误；在发送和接受时都要计算校验和。
- **流量控制和阻塞管理**。
  - 滑动窗口：控制双方的发送接受速度。
  - 流量控制用来避免主机发送得过快而使接收方来不及完全收下。

**TCP与UDP的不同点**

- 面向连接（确认有创建三方交握，连接已创建才作传输。）
- 有序数据传输
- 重发丢失的数据包
- 舍弃重复的数据包
- 无差错的数据传输
- 阻塞/流浪控制

<img src=".\images\image-20230307230049285.png" alt="image-20230307230049285" style="zoom: 33%;" />

<center>图1-2 TCP通信结构图</center>