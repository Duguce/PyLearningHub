# PyBasic学习笔记

Abstract：本文是根据作者巩固学习Python基础知识时所做的一些笔记，其中也包含一些代码示例。

Author： Duguce

Email：zhgyqc@163.com

Datetime:  2022-02-20 18:33 —— 2022-02-27 18:59

--------

- [1 Python初识](#1-python初识)
  - [1.1 Python起源](#11-python起源)
  - [1.2 Python的设计目标](#12-python的设计目标)
  - [1.3 Python的优缺点](#13-python的优缺点)
  - [1.4 Python代码风格](#14-python代码风格)
- [2 变量的基本使用](#2-变量的基本使用)
  - [2.1 变量的定义](#21-变量的定义)
  - [2.2 变量的类型](#22-变量的类型)
  - [2.3 不同类型变量之间的计算](#23-不同类型变量之间的计算)
  - [2.4 变量的输入](#24-变量的输入)
  - [2.5 变量的格式化输出](#25-变量的格式化输出)
  - [2.6 变量的命名](#26-变量的命名)
  - [2.7 变量进阶](#27-变量进阶)
- [3 运算符](#3-运算符)
  - [3.1 算术运算符](#31-算术运算符)
  - [3.2 比较运算符](#32-比较运算符)
  - [3.3 逻辑运算符](#33-逻辑运算符)
  - [3.4 赋值运算符](#34-赋值运算符)
  - [3.5 位运算符](#35-位运算符)
  - [3.6 运算符的优先级](#36-运算符的优先级)
- [4 判断语句](#4-判断语句)
  - [4.1 基本语法](#41-基本语法)
  - [4.2 高级用法](#42-高级用法)
- [5 循环语句](#5-循环语句)
  - [5.1 for循环](#51-for循环)
  - [5.2 while循环](#52-while循环)
  - [5.3 break\&continue](#53-breakcontinue)
- [6 函数](#6-函数)
  - [6.1 函数的返回值](#61-函数的返回值)
  - [6.2 函数的参数](#62-函数的参数)
  - [6.3 函数的递归](#63-函数的递归)
- [7 面向对象](#7-面向对象)
  - [7.1 面向对象基础概念](#71-面向对象基础概念)
  - [7.2 类和对象](#72-类和对象)
  - [7.3 面向对象基础语法](#73-面向对象基础语法)
  - [7.4 面向对象的封装](#74-面向对象的封装)
  - [7.5 面向对象的继承](#75-面向对象的继承)
  - [7.6 面向对象的多态](#76-面向对象的多态)
  - [7.7 类属性和类方法](#77-类属性和类方法)
  - [7.8 单例](#78-单例)
- [8 异常](#8-异常)
  - [8.1 异常的概念](#81-异常的概念)
  - [8.2 捕获异常](#82-捕获异常)
- [9 模块和包](#9-模块和包)
  - [9.1 模块](#91-模块)
  - [9.2 包](#92-包)
- [10 文件](#10-文件)
  - [10.1 文件的概念](#101-文件的概念)
  - [10.2 文件的基本操作](#102-文件的基本操作)
  - [10.3 文件/目录的常用管理操作](#103-文件目录的常用管理操作)

-----


## 1 Python初识

>  Life is short, you need Python.

### 1.1 Python起源

Python 是由 Guido van Rossum 在 1989 年开始开发的一种编程语言。当时，Guido 在荷兰国家数学和计算机科学研究所工作，他希望开发一种易于使用的语言，能够代替 ABC 语言（一种被广泛用于教学和科学计算的语言），同时又能具备更强大的功能。

Python 的名字来源于 Monty Python 的电视喜剧，这也是 Guido 的兴趣之一。Guido 开发 Python 的初衷是为了提高自己的工作效率，但很快他就意识到这种语言可以成为一种非常有用的工具，可以帮助其他人解决编程问题。

在 1991 年，Guido 发布了 Python 的第一个版本，这个版本被称为 Python 0.9.0。此后，Python 逐渐得到越来越多的关注和支持，成为了一种备受欢迎的编程语言。现在，Python 成为了一种广泛用于各种应用领域的编程语言，如数据分析、机器学习、Web 开发等等。

### 1.2 Python的设计目标

Python 的设计目标是成为一种易于学习、易于使用、可读性高、代码简洁优雅的编程语言，同时也要具备足够的灵活性和功能强大的特性。

以下是 Python 的一些设计目标：

- 易于学习和使用：Python 的语法简单明了，易于学习和理解，同时也具有友好的开发环境和交互式解释器，可以帮助用户快速上手。
- 可读性高：Python 的代码具有良好的可读性，语法简洁，缩进等特征可以使代码更加清晰易懂。
- 代码简洁优雅：Python 鼓励使用简单和优美的代码，而不是复杂和冗长的代码，这使得代码更加易于维护和修改。
- 功能强大：Python 内置了大量的库和工具，支持各种编程任务，例如网络编程、GUI 编程、数据库编程、科学计算和机器学习等等。
- 可移植性：Python 可以在多个操作系统和硬件平台上运行，因此它是一种非常灵活的编程语言。
- 开放性：Python 是一种开源语言，用户可以自由地修改和分发 Python 的代码，这也促进了 Python 社区的繁荣和发展。

### 1.3 Python的优缺点

**优点**

- 简单易学：Python 的语法简单明了，易于学习和理解。
- 通用性：Python 可以用于各种应用领域，例如网络编程、GUI 编程、数据库编程等等。
- 高级数据结构：Python 内置了许多高级数据结构，例如列表、字典和集合等。
- 自动内存管理：Python 具有自动内存管理功能，减轻了程序员的负担。
- 开源：Python 是一种开源语言，可以在不同的操作系统和硬件平台上使用。
- 大量的标准库和第三方库：Python 拥有丰富的标准库和第三方库，可以帮助程序员快速开发各种应用程序。

**缺点**

- 运行速度较慢：相对于 C++、Java 等编程语言，Python 的运行速度较慢，这主要是因为 Python 是解释型语言，需要在运行时解释代码。
- 内存占用较大：Python 为了提高开发效率，采用了自动内存管理的机制，这会导致一些内存占用问题，因此在处理大量数据时可能会出现内存问题。
- 不适合开发大型系统：Python 是一种动态类型语言，缺乏类型检查功能，因此在开发大型系统时，可能会出现类型不匹配、难以调试的问题。同时，Python 在多线程处理方面也存在一些问题，不太适合开发高并发的系统。
- 代码保护性较差：由于 Python 是一种开源语言，代码很容易被反编译或修改，因此在开发一些商业软件或安全性要求较高的系统时，需要进行额外的安全保护措施。（代码在服务器上可以被看到）
- 依赖管理和版本兼容性问题：Python 的第三方库和工具非常丰富，但是不同库之间可能存在版本兼容性问题，同时也需要考虑库的依赖管理问题。

### 1.4 Python代码风格

Python官方提供了一系列PEP（Python Enhancement Proposals）文档，其中第8篇专门针对Python的代码风格给出了建议，即俗称的PEP8，文档地址为：https://peps.python.org/pep-0008/。另外，谷歌有对应的中文文档：https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/。

## 2 变量的基本使用

### 2.1 变量的定义

在Python中，每一个变量在使用前都必须赋值，变量赋值以后，改变了才会被创建。在Python中使用"="来给变量赋值。例如：

```python
name = "xiaoce"
```

### 2.2 变量的类型

在 Python 中，变量的类型包括以下几种：

- 数字型变量：包括整型、浮点型、复数型等。整型表示整数，浮点型表示带小数点的数字，复数型表示实部和虚部组成的数字。例如：`a = 10`、`b = 3.14`、`c = 1 + 2j`。
- 布尔型变量：只有两个取值，True 和 False。布尔型变量通常用于逻辑判断。例如：`d = True`、`e = False`。
- 字符串变量：表示一串字符组成的文本，可以用单引号、双引号、三引号表示。例如：`f = 'hello world'`、`g = "python is awesome"`。
- 列表变量：表示一组有序的元素，可以包含不同类型的元素，用方括号括起来。例如：`h = [1, 2, 'hello', True]`。
- 元组变量：与列表类似，但是元组是不可变的，用小括号括起来。例如：`i = (1, 2, 'hello', True)`。
- 字典变量：表示一组无序的键值对，用花括号括起来，每个键值对之间用逗号分隔。例如：`j = {'name': 'Alice', 'age': 25, 'city': 'Beijing'}`。
- 集合变量：表示一组无序的、不重复的元素，用大括号括起来。例如：`k = {1, 2, 3, 4}`。

这些变量类型在 Python 中都有其特定的使用场景，使用时需要根据实际情况选择合适的类型。

### 2.3 不同类型变量之间的计算

在 Python 中，不同类型的变量之间进行计算时，会遵循一定的规则和转换方式。下面是一些常见的计算规则：

- 数字型变量之间可以进行加减乘除等算术运算。整型和浮点型之间可以相互转换，复数型不支持大小比较和位运算。例如：

```python
a = 10
b = 3.14
c = 2 + 3j

d = a + b  # 整型和浮点型相加，结果为浮点型
e = a * c  # 整型和复数型相乘，结果为复数型
f = b / a  # 浮点型和整型相除，结果为浮点型
```

布尔型变量之间可以进行逻辑运算（与、或、非等），可以转换成整型进行数值运算（True 转换为 1，False 转换为 0）。例如：

```python
a = True
b = False

c = a and b  # 逻辑与运算，结果为 False
d = int(a) + int(b)  # 布尔型转换为整型进行加法运算，结果为 1
```

字符串变量可以进行加法运算（表示字符串拼接），不能进行其他数值运算。例如：

```python
a = 'hello'
b = 'world'

c = a + b  # 字符串拼接，结果为 'helloworld'
```

列表、元组和集合变量之间可以进行加法运算（表示集合并集），不能进行其他数值运算。例如：

```python
a = [1, 2, 3]
b = (4, 5, 6)
c = {1, 2, 3}

d = a + list(b)  # 列表和元组相加，结果为 [1, 2, 3, 4, 5, 6]
e = c.union(a)  # 集合并集，结果为 {1, 2, 3, 4, 5, 6}
```

字典变量不能进行数值运算，但可以进行键值对的增删改查等操作。例如：

```python
a = {'name': 'Alice', 'age': 25}

a['city'] = 'Beijing'  # 增加一个键值对
a['age'] = 26  # 修改一个键值对
del a['name']  # 删除一个键值对
```

对于不同类型变量之间的比较，通常按照以下规则进行：

- 数字型变量之间可以进行大小比较，但整型和浮点型之间大小比较时，会将整型转换为浮点型再进行比较。复数型不支持大小比较。
- 布尔型变量之间可以进行相等性比较（== 或 !=），不能进行大小比较。
- 字符串变量之间可以进行大小比较（按字典序），但不能与数字型变量进行大小比较。
- 列表、元组和集合变量之间可以进行相等性比较和包含性比较（in 和 not in），但不能进行大小比较。
- 字典变量之间只能进行相等性比较和键的包含性比较（in 和 not in），不能进行大小比较。

```python
a = 10
b = 3.14
c = 'hello'
d = [1, 2, 3]

e = a > b  # 整型和浮点型比较，结果为 True
f = c < 'world'  # 字符串比较，结果为 True
g = 2 in d  # 列表包含性比较，结果为 True
h = {'name': 'Alice', 'age': 25} == {'age': 25, 'name': 'Alice'}  # 字典相等性比较，结果为 True
```

### 2.4 变量的输入

在 Python 中，可以使用内置函数 `input()` 来实现变量的输入操作。`input()` 函数会在程序执行过程中等待用户输入，然后将用户输入的内容以字符串形式返回，程序可以将其赋值给一个变量来保存。

下面是一个简单的示例，演示了如何使用 `input()` 函数实现变量的输入：

```python
name = input('请输入您的名字：')
age = input('请输入您的年龄：')

print('您的名字是：', name)
print('您的年龄是：', age)
```

在上面的代码中，我们首先使用 `input()` 函数等待用户输入名字和年龄，并将它们分别保存到变量 `name` 和 `age` 中。然后，我们使用 `print()` 函数输出这些变量的值。

当程序执行到 `input()` 函数时，程序会停止在这里，等待用户输入。用户输入完成后，按下回车键，`input()` 函数会返回用户输入的内容，并将其作为字符串类型的结果返回。因此，我们需要将输入的内容转换为相应的数据类型，比如整型、浮点型等，以便程序后续进行数值计算和其他操作。例如，如果想将输入的年龄转换为整型，可以使用如下代码：

```python
age = int(input('请输入您的年龄：'))
```

需要注意的是，`input()` 函数返回的是字符串类型的值，如果用户输入的内容不是合法的数字字符串，或者不符合程序的期望输入格式，程序可能会出现错误。因此，在实际编程中，我们需要对用户输入进行一定的验证和处理，以确保程序能够正确运行。

### 2.5 变量的格式化输出

在 Python 中，可以使用不同的方式来实现变量的格式化输出，常见的方法包括：

- 使用字符串的格式化方法 `%` 或 `format()`；
- 使用 f-string（Python 3.6 及以上版本支持）。

下面分别介绍一下这些方法的用法。

**使用字符串的格式化方法 `%`**

在 Python 中，可以使用 `%` 运算符来实现字符串的格式化输出。具体来说，可以使用 `%` 运算符在字符串中指定一个或多个占位符，然后使用一个元组（或字典）来填充这些占位符，最终得到格式化后的字符串。

占位符以 `%` 开头，后面跟一个字母，表示占位符的类型。常见的占位符类型包括：

- `%d`：整数类型；
- `%f`：浮点数类型；
- `%s`：字符串类型；
- `%x`：十六进制整数类型。

例如，下面的代码演示了如何使用 `%` 方法实现变量的格式化输出：

```python
name = 'Alice'
age = 25
height = 1.75

# 使用 % 方法进行格式化输出
print('我叫 %s，今年 %d 岁，身高 %.2f 米。' % (name, age, height))
```

在上面的代码中，我们使用 `%` 运算符在字符串中指定了三个占位符 `%s`、`%d` 和 `%.2f`，分别表示字符串、整数和浮点数类型。然后，我们在使用 `print()` 函数输出字符串时，使用一个元组 `(name, age, height)` 来填充这些占位符，得到最终的格式化输出结果。

需要注意的是，使用 `%` 方法进行格式化输出时，需要注意占位符的类型和数量，否则可能会出现错误。同时，使用 `%` 方法进行格式化输出可能会让代码可读性较差，因为占位符与填充变量之间的关系不够直观。

**使用字符串的 `format()` 方法**

```python
name = 'Alice'
age = 25
height = 1.75

# 使用 format() 方法进行格式化输出
print('我叫 {}，今年 {} 岁，身高 {:.2f} 米。'.format(name, age,
```

在上面的代码中，我们使用 `format()` 方法指定了三个占位符 `{}`，然后在调用 `format()` 方法时，使用变量名 `name`、`age` 和 `height` 来填充这些占位符，得到最终的格式化输出结果。

需要注意的是，在使用 `format()` 方法进行格式化输出时，占位符的顺序可以与填充变量的顺序不同，因为 `format()` 方法会根据占位符的位置来确定填充的变量。

除了位置参数外，`format()` 方法还支持关键字参数的方式来传递参数。例如，下面的代码演示了如何使用关键字参数的方式实现变量的格式化输出：

```python
name = 'Alice'
age = 25
height = 1.75

# 使用 format() 方法进行格式化输出
print('我叫 {name}，今年 {age} 岁，身高 {height:.2f} 米。'.format(name=name, age=age, height=height))
```

**使用 f-string**

f-string 是 Python 3.6 新增的一种字符串格式化方法，它使用一种类似于模板字符串的语法，可以在字符串中直接使用变量名，然后使用花括号 `{}` 来表示占位符。例如，下面的代码演示了如何使用 f-string 实现变量的格式化输出：

在上面的代码中，我们在字符串前面加上了一个 `f`，表示这是一个 f-string。然后，在字符串中使用变量名来表示占位符，使用花括号 `{}` 来包含占位符。需要注意的是，在花括号中，还可以使用一些格式化字符串的语法，例如 `{height:.2f}` 表示将 `height` 变量格式化为浮点数，并保留两位小数。

f-string 是一种比较新的字符串格式化方法，相比于 `%` 和 `format()` 方法，它的代码更加简洁、直观，也更加易读。但是，f-string 的主要限制是它只能在 Python 3.6 及以上版本中使用。

### 2.6 变量的命名

**标识符**

在Python中，标识符是指用来标识某个变量、函数、类或模块等对象的名称。Python中的标识符必须满足以下规则：

- 标识符由字母、数字、下划线组成，不能以数字开头；
- 标识符区分大小写；
- 不能使用Python关键字作为标识符名称。

**关键字**

Python关键字是指在Python语言中有特殊含义的单词。这些关键字被Python编译器用于识别程序的结构和功能，不能用作标识符名称。Python中的关键字共有35个，包括：

```
False, None, True, and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield
```

其中，`False`, `None`, `True` 是Python中的三个特殊的常量；`and`, `or`, `not` 是逻辑运算符；`if`, `else`, `elif` 是条件语句关键字；`for`, `while` 是循环语句关键字；`def` 是定义函数的关键字；`class` 是定义类的关键字，等等。

**变量的命名规则**

在 Python 中，变量名必须遵循以下规则：

1. 变量名只能包含字母（大写或小写）、数字和下划线（_），不能以数字开头。
2. 变量名区分大小写，例如 `apple` 和 `Apple` 是不同的变量名。
3. 变量名不能是 Python 的关键字（也称保留字），如 `if`、`for`、`while` 等。

除了上述规则外，Python 还有一些惯例：

1. 变量名通常是小写的，用下划线分隔单词以提高可读性，例如 `my_variable_name`。
2. 类名通常是以大写字母开头的单词，不使用下划线分隔单词，例如 `MyClass`。
3. 常量名通常是全大写的单词，用下划线分隔单词，例如 `MY_CONSTANT`。

另外，Python中还有大驼峰命名法（PascalCase）和小驼峰命名法（camelCase）。这是两种常用的变量命名规范，通常用于编程语言中。

在大驼峰命名法中，每个单词的首字母都要大写，单词之间没有下划线。这种命名法通常用于类名、构造函数、枚举等。

例如：MyClass、MyFirstVariable

在小驼峰命名法中，第一个单词的首字母小写，后面的单词的首字母大写，单词之间也没有下划线。这种命名法通常用于变量名、函数名、方法名等。

例如：myVariable、myFirstFunction

在Python中，通常使用小写字母加下划线的命名法（snake_case）作为变量、函数和方法的命名规范。不过在特定的情况下，也可以使用大驼峰或小驼峰命名法。

### 2.7 变量进阶

**变量的引用**

- 变量和数据都是保存在内存中的；
- 在Python中函数的参数传递以及返回值都是靠引用传递的；
- 变量和数据是分开存储的；
- 数据保存在内存中的一个位置；
- 变量中保存着数据在内存中的地址；
- 变量中记录数据的地址，就叫做引用；
- 使用id()函数可以查看变量中保存数据所在的内存地址。

注：如果变量已经被定义，当给一个变量赋值时，本质是修改了数据的引用。

- 变量不再对之前的数据引用；
- 变量改为对新赋值的数据引用。

在Python中，函数的**实参/返回值**都是靠引用来传递的。

**可变和不可变类型**

- 不可变类型，内存中的数据不允许被修改：
  - 数字类型 int, bool, float. complex
  - 字符串 str
  - 元组 tuple

不可以实现在被调函数内去修改调用函数内的某个变量值。

- 可变类型，内存中的数据可以被修改：
  - 列表 list
  - 字典 dict
  - 集合 set

通过接口改变的数据所在的位置，变量的地址没变。

**局部变量和全局变量**

- 局部变量是在函数内部定义的变量，只能在函数内部使用；
- 全局变量是在函数外部定义的变量，所有函数内部都可以使用这个变量。

:star:局部变量

- 局部变量是在函数内部定义的变量，只能在函数内部使用；
- 函数执行结束后，函数内部的局部变量，会被系统回收；
- 不同的函数，可以定义相同的名字的局部变量，但是彼此之间不会产生影响。

局部变量的生命周期

- 所谓生命周期就是变量从被创建到被系统回收的过程；
- 局部变量在函数执行时才会被创建；
- 函数执行结束后局部变量被系统回收；
- 局部变量在生命周期内，可以用来存储函数内部临时使用到的数据。

:star:全局变量

- 全局变量是在函数外部定义的变量，所有函数内部都可以使用这个变量；
- 如果在函数中需要修改全局变量，需要使用 global 进行声明；
- 为了保证所有的函数都能够正确使用到全局变量，应该将全局变量定义在其他函数的上方。

**列表变量的引用**

下面是列表变量常用的一些接口及其对应的基本功能。

|    接口    |                      基本功能                      |
| :--------: | :------------------------------------------------: |
|  append()  |               在列表末尾添加一个元素               |
|  extend()  |               在列表末尾添加多个元素               |
|  insert()  |             在列表指定位置插入一个元素             |
|  remove()  |                从列表中删除指定元素                |
|   pop()    |     删除列表中指定位置的元素，并返回删除的元素     |
|  clear()   |                删除列表中的所有元素                |
|  index()   |              返回列表中指定元素的索引              |
|  count()   |            返回列表中指定元素的出现次数            |
|   sort()   |               对列表中的元素进行排序               |
| reverse()  |               将列表中的元素反向排列               |
|   copy()   |                   返回列表的副本                   |
|   len()    |                   返回列表的长度                   |
| getitem()  |              返回列表中指定位置的元素              |
| setitem()  |              设置列表中指定位置的元素              |
| delitem()  |              删除列表中指定位置的元素              |
|   iter()   |        返回一个迭代器，可以遍历列表中的元素        |
| reversed() |  返回一个逆向迭代器，可以从后往前遍历列表中的元素  |
| contains() |             检查列表中是否包含指定元素             |
|   add()    |             将两个列表合并成一个新列表             |
|   mul()    | 将列表重复指定次数，返回一个新的包含重复元素的列表 |
|  index()   |              返回列表中指定元素的索引              |
|  count()   |            返回列表中指定元素的出现次数            |

**元组**

- Tuple（元组）与列表类似，不同之处在于元组的元素不能修改

  - 元组表示多个元素组成的序列

  - 元组在 Python 开发中，有特定的应用场景

- 用于存储一串信息，数据之间使用 , 分隔

- 元组用 () 定义

- 元组的索引从0开始
  - 索引就是数据在元组中的位置编号

元组中常用的一些接口如下表所示

|           接口           |                       功能                        |
| :----------------------: | :-----------------------------------------------: |
|         count(x)         |           统计元素 x 在元组中出现的次数           |
| index(x[, start[, end]]) | 返回元组中第一个出现元素 x 的索引，可指定查找范围 |

**字典**

- dictionary（字典） 是除列表以外Python之中最灵活的数据类型

- 字典同样可以用来存储多个数据
  - 通常用于存储描述一个物体的相关信息

- 和列表的区别
  - 列表是有序的对象集合
  - 字典是无序的对象集合
- 字典用 {} 定义
- 字典使用键值对存储数据，键值对之间使用 , 分隔
  - 键 key 是索引，必须是不可变类型，往往是字符串
  - 值 value 是数据
  - 键和值之间使用 : 分隔
  - 键必须是唯一的
  - 值可以取任何数据类型，但键只能使用字符串、数字或元组

以下是 Python 中字典常用的接口及其对应的基本功能：

|      接口/方法      |                        功能                        |
| :-----------------: | :------------------------------------------------: |
|    {key: value}     |                    创建一个字典                    |
|       dict()        |                    创建一个字典                    |
|        len()        |               返回字典中键值对的数量               |
|      in 运算符      |              检查给定的键是否在字典中              |
|    not in 运算符    |             检查给定的键是否不在字典中             |
|         del         |               删除字典中指定的键值对               |
|       clear()       |               删除字典中的所有键值对               |
|       keys()        |               返回字典中所有键的列表               |
|      values()       |               返回字典中所有值的列表               |
|       items()       |             返回字典中所有键值对的列表             |
| get(key[, default]) |    返回字典中给定键的值，如果键不存在返回默认值    |
| pop(key[, default]) | 返回并删除字典中给定键的值，如果键不存在返回默认值 |
|      popitem()      |            返回并删除字典中的一个键值对            |
|    update(dict2)    |       将字典 dict2 的键值对添加到当前字典中        |
|       copy()        |                 创建一个字典的副本                 |

**字符串**

- 字符串就是一串字符，是编程语言中表示文本的数据类型
- 在 Python 中可以使用一对双引号 " 或者 一对单引号 ' 定义一个字符串
  - 虽然可以使用 \" 或者 \' 做字符串的转义，但是在实际开发中：
    - 如果字符串内部需要使用 "，可以使用 ' 定义字符串
    - 如果字符串内部需要使用 '，可以使用 " 定义字符串
- 可以使用索引获取一个字符串中指定位置的字符，索引计数从0开始
- 也可以使用循环遍历字符串中每一个字符

以下是 Python 中字符串常用的接口及其对应的基本功能：

|   接口/方法   |                       功能                       |
| :-----------: | :----------------------------------------------: |
|     len()     |                 返回字符串的长度                 |
|   + 运算符    |               将两个字符串拼接起来               |
|   * 运算符    |               将一个字符串重复多次               |
|   in 运算符   |      检查一个字符串是否包含在另一个字符串中      |
| not in 运算符 |     检查一个字符串是否不包含在另一个字符串中     |
|     str()     |            将一个对象转换成字符串类型            |
|    lower()    |            将字符串转换成小写字母形式            |
|    upper()    |            将字符串转换成大写字母形式            |
|    strip()    |          删除字符串开头和结尾的空白字符          |
|   lstrip()    |             删除字符串开头的空白字符             |
|   rstrip()    |             删除字符串结尾的空白字符             |
|   replace()   |       将字符串中的某个子串替换成另一个子串       |
|    split()    |              将字符串分割成子字符串              |
|    join()     |         将一个字符串列表合并成一个字符串         |
|   format()    |                   格式化字符串                   |
|   isalpha()   |             检查字符串是否只包含字母             |
|   isdigit()   |             检查字符串是否只包含数字             |
|   isalnum()   |          检查字符串是否只包含字母和数字          |
|   isspace()   |           检查字符串是否只包含空白字符           |
| startswith()  |           检查字符串是否以给定子串开头           |
|  endswith()   |           检查字符串是否以给定子串结尾           |
|    index()    |           返回给定子串在字符串中的位置           |
|    count()    |         返回给定子串在字符串中出现的次数         |
| capitalize()  |       将字符串第一个字符转换成大写字母形式       |
|    title()    | 将字符串中每个单词的第一个字符转换成大写字母形式 |

**集合**

在 Python 中，集合是一种无序且不重复的数据结构，用于存储一组唯一的对象。Python 中的集合对象是可变的，意味着可以随意添加、删除或更新其中的元素。集合是通过大括号 {} 或 set() 函数来创建的，其中大括号 {} 用于创建空集合，而 set() 函数可以将其他数据类型（如列表、元组、字符串等）转换为集合。

以下是 Python 中集合的常用操作和方法：

|     操作/方法      |                             功能                             |
| :----------------: | :----------------------------------------------------------: |
|      创建集合      |   用大括号 {} 或 set() 函数创建一个空集合或包含元素的集合    |
|      添加元素      |               使用 add() 方法向集合中添加元素                |
|      更新集合      |            使用 update() 方法向集合中添加多个元素            |
|      删除元素      |     使用 remove() 或 discard() 方法从集合中删除指定元素      |
|    随机删除元素    |           使用 pop() 方法从集合中随机删除一个元素            |
|      清空集合      |                  使用 clear() 方法清空集合                   |
|  检查元素是否存在  |      使用 in 或 not in 运算符检查集合中是否存在指定元素      |
|   获取集合的长度   |             使用 len() 函数获取集合中元素的数量              |
|      比较集合      |           使用 == 或 != 运算符比较两个集合是否相等           |
|   集合操作：并集   |                      使用 union() 或 \|                      |
|   集合操作：交集   |      使用 intersection() 或 & 运算符获取两个集合的交集       |
|   集合操作：差集   |       使用 difference() 或 - 运算符获取两个集合的差集        |
| 集合操作：对称差集 | 使用 symmetric_difference() 或 ^ 运算符获取两个集合的对称差集 |
|      检查子集      |    使用 issubset() 方法检查一个集合是否是另一个集合的子集    |
|      检查超集      |   使用 issuperset() 方法检查一个集合是否是另一个集合的超集   |

以下是一些使用集合的例子：

```python
# 创建集合
s1 = {1, 2, 3}
s2 = set([2, 3, 4])

# 添加元素
s1.add(4)
print(s1)       # 输出 {1, 2, 3, 4}

# 更新集合
s1.update([5, 6, 7])
print(s1)       # 输出 {1, 2, 3, 4, 5, 6, 7}

# 删除元素
s1.remove(6)
print(s1)       # 输出 {1, 2, 3, 4, 5, 7}

# 随机删除元素
s1.pop()
print(s1)       # 输出 {2, 3, 4, 5, 7}

# 清空集合
s1.clear
```

## 3 运算符

Python中的运算符包括：算术运算符、比较运算符、赋值运算符、逻辑运算符、位运算符等等。这些运算符可以用于不同类型的操作数，包括数字、字符串、列表、元组、字典等数据类型，同时这些运算符之间还存在优先级。

### 3.1 算术运算符

算术是完成基本的算术运算使用的符号，用来处理四则运算。

| 运算符 |                        描述                        |    示例     |
| :----: | :------------------------------------------------: | :---------: |
|   +    |                加法，返回两个数的和                |  3 + 5 = 8  |
|   -    |          减法，返回一个数减去另一个数的差          |  7 - 2 = 5  |
|   *    |                乘法，返回两个数的积                | 3 * 4 = 12  |
|   /    |          除法，返回一个数除以另一个数的商          | 10 / 2 = 5  |
|   //   | 整除，返回一个数除以另一个数的商，但是去掉小数部分 | 10 // 3 = 3 |
|   %    |             取模，返回两个数相除的余数             | 10 % 3 = 1  |
|   **   |             幂运算，返回一个数的几次方             | 2 ** 3 = 8  |

Python中算术运算符的优先级从高到低依次为：

|  运算符  |       描述       |
| :------: | :--------------: |
|    **    |      幂运算      |
| * / % // | 乘、除、模、整除 |
|   + -    |      加、减      |

优先级高的运算符先计算，优先级相同的从左往右计算。如果有多个运算符混合在一起，可以使用括号改变优先级，或者使用表格中的优先级规则确定计算顺序。

### 3.2 比较运算符

比较运算符是用来比较两个值之间的关系，并返回布尔值（True或False）的运算符。Python中的比较运算符包括以下几种：

| 运算符 |   描述   |
| :----: | :------: |
|   ==   |   等于   |
|   !=   |  不等于  |
|   >    |   大于   |
|   <    |   小于   |
|   >=   | 大于等于 |
|   <=   | 小于等于 |

这些运算符通常用于条件语句和循环语句中，比如if语句、while语句、for语句等。比较运算符的运算结果是布尔值，即True或False。例如，2 < 3的结果是True，"hello" == "world"的结果是False。

需要注意的是，比较运算符只能用于比较相同类型的值，比较不同类型的值会引发TypeError异常。例如，不能比较一个字符串和一个整数的大小，比较它们的大小会引发TypeError异常。

### 3.3 逻辑运算符

在Python中，逻辑运算符包括`and`、`or`、`not`三个。

- `and`：如果两个操作数都为真，则结果为真，否则结果为假。示例：`True and False`返回`False`，`1 < 2 and 3 < 4`返回`True`。
- `or`：如果两个操作数至少有一个为真，则结果为真，否则结果为假。示例：`True or False`返回`True`，`1 < 2 or 3 > 4`返回`True`。
- `not`：如果操作数为假，则结果为真，否则结果为假。示例：`not True`返回`False`，`not False`返回`True`。

逻辑运算符通常用于控制程序流程，例如条件语句、循环语句等。同时，在Python中也可以使用逻辑运算符来对变量或表达式进行组合判断。

### 3.4 赋值运算符

| 运算符 |                           描述                           |             实例             |
| :----: | :------------------------------------------------------: | :--------------------------: |
|   =    |                 将右边的值赋给左边的变量                 |      a = 5, b = 'hello'      |
|   +=   |      将右边的值加上左边的值，并将结果赋给左边的变量      |  a += 2 (相当于 a = a + 2)   |
|   -=   |      将左边的值减去右边的值，并将结果赋给左边的变量      |  b -= 3 (相当于 b = b - 3)   |
|   *=   |      将左边的值乘以右边的值，并将结果赋给左边的变量      |  a *= 3 (相当于 a = a * 3)   |
|   /=   |      将左边的值除以右边的值，并将结果赋给左边的变量      |  b /= 2 (相当于 b = b / 2)   |
|  //=   | 将左边的值除以右边的值，向下取整，并将结果赋给左边的变量 | a //= 2 (相当于 a = a // 2)  |
|   %=   | 将左边的值除以右边的值，得到余数，并将结果赋给左边的变量 |  b %= 2 (相当于 b = b % 2)   |
|  **=   |      左边的值的右边的值次幂，并将结果赋给左边的变量      | a \**= 2 (相当于 a = a ** 2) |

### 3.5 位运算符

位运算符是Python中一类对二进制数进行操作的运算符，它们将二进制数看做一个整体进行位运算，因此通常用于比特处理，计算机网络，加密和解密等方面。Python中支持以下位运算符：

1. 按位与（&）：如果两个二进制位都为 1，则将该位设为 1，否则为 0。

   例如，对于整数 3 和 6，它们的二进制表示分别为 0011 和 0110，进行按位与运算后得到结果 0010，对应的十进制数为 2。

2. 按位或（|）：如果两个二进制位中至少有一个为 1，则将该位设为 1，否则为 0。

   例如，对于整数 3 和 6，它们的二进制表示分别为 0011 和 0110，进行按位或运算后得到结果 0111，对应的十进制数为 7。

3. 按位异或（^）：如果两个二进制位不相同，则将该位设为 1，否则为 0。

   例如，对于整数 3 和 6，它们的二进制表示分别为 0011 和 0110，进行按位异或运算后得到结果 0101，对应的十进制数为 5。

4. 按位取反（~）：对二进制数按位取反，即将 0 变为 1，将 1 变为 0。

   例如，对于整数 3，它的二进制表示为 0011，进行按位取反运算后得到结果 1100，对应的十进制数为 -4。

5. 左移（<<）：将二进制数向左移动指定的位数，右侧补零。

   例如，对于整数 3，它的二进制表示为 0011，进行左移 2 位后得到结果 1100，对应的十进制数为 12。

6. 右移（>>）：将二进制数向右移动指定的位数，左侧补零或者补符号位。例如，对于整数 10，它的二进制表示为 1010，进行右移 2 位后得到结果 0010，对应的十进制数为 2。

```python
a = 60
b = 13
c = 0

c = a & b
print("按位与运算：", c)

c = a | b
print("按位或运算：", c)

c = a ^ b
print("按位异或运算：", c)

c = ~a
print("按位取反运算：", c)

c = a << 2
print("左移运算：", c)

c = a >> 2
print("右移运算：", c)
```

### 3.6 运算符的优先级

|  运算符说明  |                Python 运算符                 | 优先级 | 结合性 |
| :----------: | :------------------------------------------: | :----: | :----: |
|     括号     |                      ()                      |   1    | 左到右 |
|     指数     |                      **                      |   2    | 右到左 |
|    正负号    |                    +x, -x                    |   3    | 左到右 |
| 乘、除、取模 |                   *, /, %                    |   4    | 左到右 |
|    加、减    |                     +, -                     |   5    | 左到右 |
|   位移运算   |                    <<, >>                    |   6    | 左到右 |
|    位运算    |                 &, \|, ^, ~                  |   7    | 左到右 |
|   比较运算   |             <, <=, >, >=, ==, !=             |   8    | 左到右 |
|   逻辑运算   |                 not, and, or                 |   9    | 左到右 |
|   赋值运算   | =, +=, -=, *=, /=, %=, &=, ^=, \|=, <<=, >>= |   10   | 右到左 |

其中，结合性指的是同优先级运算符的执行顺序方向，左到右表示从左往右依次执行，右到左表示从右往左依次执行。优先级顺序指的是运算符优先级从高到低的顺序。注意，优先级顺序只针对同一层级的运算符，不同层级之间优先级顺序不一定。

## 4 判断语句

Python中的判断语句使用if语句来实现，if语句可以根据条件的成立与否来执行相应的代码块。

### 4.1 基本语法

if语句的基本语法如下：

```python
if 条件1:
    代码块1
elif 条件2:
    代码块2
else:
    代码块3
```

其中，elif和else语句是可选的。如果条件1成立，则执行代码块1；如果条件1不成立，则判断条件2，如果条件2成立，则执行代码块2；如果条件2不成立，则执行代码块3。

在Python中，条件表达式可以是任何返回布尔值（True或False）的表达式，例如比较运算符、逻辑运算符、成员运算符等。在判断语句中，条件表达式的值为True时执行相应的代码块，值为False时不执行。

下面是一个简单的if语句的例子：

```python
x = 5
if x > 0:
    print("x is positive")
else:
    print("x is non-positive")
```

这个例子中，如果x的值大于0，则输出"x is positive"；否则输出"x is non-positive"。

### 4.2 高级用法

**if-elif-else语句**

if-elif-else语句是在if语句基础上的扩展，可以用来处理多个条件的情况。其示例代码如下：

```python
score = 80

if score >= 90:
    print('优秀')
elif score >= 80:
    print('良好')
elif score >= 70:
    print('一般')
else:
    print('不及格')
```

**嵌套的if语句**

在if语句中嵌套if语句，可以实现更加复杂的判断逻辑。其示例代码如下：

```python
age = 18
sex = '男'

if age >= 18:
    if sex == '男':
        print('成年男性')
    else:
        print('成年女性')
else:
    print('未成年')
```

**三元表达式**

```python
score = 80
result = '及格' if score >= 60 else '不及格'
print(result)
```

**if语句中的短路运算**

在if语句中，可以使用and和or运算符实现短路运算。当使用and运算符时，如果第一个条件为False，则不再执行后面的条件；当使用or运算符时，如果第一个条件为True，则不再执行后面的条件。这种方法可以有效地简化if语句的判断过程。

```python
a = 10
b = 5

# 使用and运算符实现短路运算
if a > 5 and b < 10:
    print('a大于5，b小于10')

# 使用or运算符实现短路运算
if a > 5 or b < 3:
    print('a大于5或者b小于3')
```

## 5 循环语句

Python中的循环语句包括for循环和while循环。它们可以用来重复执行一段代码，直到满足某个条件才停止循环。

### 5.1 for循环

for循环用于遍历一个可迭代对象（如列表、元组、字符串等）中的所有元素，并对每个元素执行相同的操作。

其中，变量是每次循环中代表当前元素的变量名，可迭代对象是要遍历的对象，循环体语句是要执行的操作。

下面是一个简单的for循环示例，用于计算列表中所有元素的和：

```python
nums = [1, 2, 3, 4, 5]
sum = 0
for num in nums:
    sum += num
print(sum)
```

### 5.2 while循环

while循环用于在条件满足的情况下重复执行一段代码。语法格式如下：

其中，条件是一个表达式，循环体语句是要执行的操作。在每次循环开始时，都会先判断条件是否满足，如果满足则执行循环体语句，否则跳出循环。

下面是一个简单的while循环示例，用于计算所有小于10的正整数的和：

```python
sum = 0
num = 1
while num < 10:
    sum += num
    num += 1
print(sum)
```

### 5.3 break&continue

在循环中可以使用`break`语句和`continue`语句来控制循环的行为。`break`语句用于跳出循环，而`continue`语句用于跳过当前循环中的某个元素，直接进入下一次循环。下面是一个简单的示例，用于查找列表中第一个大于等于5的元素：

```python
nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
for num in nums:
    if num >= 5:
        print(num)
        break
```

另外，Python中还有一个`else`子句，它可以与循环配合使用，用于在循环结束后执行一些操作。如果循环中没有执行`break`语句，那么`else`子句中的语句将被执行；否则将跳过`else`子句中的语句。下面是一个简单的示例，用于查找列表中是否存在负数：

```python
nums = [1, 2, 3, -4, 5]
for num in nums:
    if num < 0:
        print("列表中存在负数")
        break
else:
    print("列表中不存在负数")
```

## 6 函数

函数根据有没有参数以及有没有返回值，可以相互组合，一共有4种组合形式：

- 无参数，无返回值
- 无参数，有返回值
- 有参数，无返回值
- 有参数，有返回值

### 6.1 函数的返回值

- 在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理；
- 返回值是函数完成工作后，最后给调用者的一个结果；
- 在函数中使用return关键字可以返回结果；
- 调用函数一方，可以使用变量来接收函数的返回结果。

### 6.2 函数的参数

无论传递的参数是可变还是不可变，只要针对参数使用赋值语句，会在函数内部修改局部变量的引用， 不会影响到外部变量的引用。

如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据。

**缺省参数**

- 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数；
- 调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值；
- 函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用；
- 定义缺省参数时，必须保证带有默认值的缺省参数 在参数列表末尾；
- 在调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系。如果都不指定是可以的，指定一个以后，后面的就必须指定。

**多值参数**

- 有，这个时候，就可以使用多值参数
- python 中有两种多值参数：
  - 参数名前增加一个 * 可以接收元组
  - 参数名前增加两个 * 可以接收字典
- 一般在给多值参数命名时，习惯使用以下两个名字
  - *args —— 存放 元组 参数，前面有一个 * 
  - \**kwargs —— 存放 字典 参数，前面有两个 * 
- args 是 arguments 的缩写，有变量的含义
- kw 是 keyword 的缩写，kwargs 可以记忆键值对参数
- *args 必须在**kwargs 前面

以下是一个使用 *args 和 **kwargs 的例子：

```python
def func(*args, **kwargs):
    print("Positional arguments:")
    for arg in args:
        print(arg)
    print("\nKeyword arguments:")
    for key, value in kwargs.items():
        print(key, ":", value)

# 使用位置参数调用函数
func("Hello", "World", "!")

# 使用关键字参数调用函数
func(name="Alice", age=30, city="New York")

# 使用混合参数调用函数
func("Hello", "World", name="Alice", age=30)
```

在上述代码中，func 函数定义了 \*args 和 \**kwargs 两个参数，其中 *args 用于接收不确定数量的位置参数，而 **kwargs 用于接收不确定数量的关键字参数。在函数体中，我们首先使用 for 循环打印出所有的位置参数，然后再使用 for 循环打印出所有的关键字参数及其对应的值。

在函数调用时，我们可以使用位置参数、关键字参数或混合参数的形式来传递参数。无论哪种形式，Python 都会将它们分别存储在 \*args 和 \**kwargs 中，然后将它们作为元组和字典的形式传递给函数。在函数体中，我们就可以像访问普通元组和字典一样来访问 *args 和 **kwargs 中的元素了。

### 6.3 函数的递归

在Python中，递归是指在函数内部调用自身的过程。递归是一种常用的编程技巧，它通常用于解决可以被分解为较小子问题的问题。一个递归函数必须包括两个部分：递归结束条件和递归公式。

以下是一个简单的递归函数，用于计算阶乘：

```python
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)
```

递归方法的特点：

- 递归是一个编程技巧，在处理不确定的循环条件时，非常有用。例如，遍历整个文件目录的结构。
- 递归有两个缺点：一是，速度没有循环快；二是，会栈溢出。

## 7 面向对象

### 7.1 面向对象基础概念

面向对象和面向过程是两种不同的编程方式。过程是早期的一个编程概念，过程类似于函数，只能执行，但是没有返回值。函数不仅能执行，还可以返回结果。

**面向过程**

- 面向过程是把完成某一个需求的所有步骤从头到尾逐步实现；
- 根据开发需求，将某些功能独立的代码封装成一个又一个的函数；
- 最后完成的代码就是顺序地调用不同的函数。

面向过程的特点

- 注重步骤与过程，不注重职责分工；
- 如果需求复杂，代码会变得很复杂；
- 开发复杂项目，没有固定的套路，开发难度大。

**面向对象**

相比较函数，面向对象是更大的封装，根据职责在一个对象中封装的多个方法。

- 在完成某一个需求前，首先确定职责——要做的事情（方法）；
- 根据职责确定不同的对象，在对象内部封装不同的方法（多个）；
- 最后完成的代码，就是顺序地让不同的对象调用不同的方法。

面向对象的特点

- 注重对象和职责，不同的对象承担不同的职责；
- 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路；
- 需要在面向过程基础上，再学习一些面向对象的语法。

**面向对象的三大特性**

- **封装**根据职责将属性和方法封装到一个抽象的类中；
- **继承**实现代码的重用，相同的代码不需要重复的编写；
- **多态**不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度。

### 7.2 类和对象

> 类和对象是面向对象编程的两个核心概念。

**类**

类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用。

- 特征被称为**属性**；
- 行为被称为**方法**。

类就相当于制造飞机时的图纸，是一个模板，是负责创建对象的。

在程序开发中，要设计一个类，通常要满足以下三个要素：

- 类名这类事物的名字，满足大驼峰命名法；
- 属性这类事物具有什么样的特征；
- 方法这类事物具有什么样的行为。

类名的确定有一个常用的方法，即，通过**名词提炼法**分析整个业务流程中出现的名词，通常就是要找到的类。

- 对**对象的特征描述**，通过可以定义成属性；

- **对象具有的行为**，通常可以定义成方法。

**对象**

- 对象是由类创建出来的一个具体存在，可以直接使用；
- 由哪一个类创建出来的对象，就拥有在哪一个类中定义的：
  - 属性
  - 方法
- 对象就相当于用图纸制造的飞机。

**类和对象的关系**

- 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象；
- 类只有一个，而对象可以有很多个；
  - 不同的对象之间的属性可能会各不相同；
- 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。

### 7.3 面向对象基础语法

**dir内置函数**

在Python中对象几乎是无所不在的，我们之前学习的变量、数据、函数都是对象。

在 Python 中可以使用以下两个方法验证：

- 在标识符/数据后输入一个`.`，然后按下 TAB 键，iPython 会提示该对象能够调用的方法列表；
- 使用内置函数dir传入标识符/数据，可以查看对象内的所有属性及方法。

Python中类常用的方法和属性如下表所示。

|              方法名              | 类型 |                            作用                            |
| :------------------------------: | :--: | :--------------------------------------------------------: |
|      `__init__(self, ...)`       | 方法 |                  构造函数，用于初始化对象                  |
|         `__str__(self)`          | 方法 |            将对象转换为字符串，通常用于打印对象            |
|         `__repr__(self)`         | 方法 |           返回对象的字符串表示形式，通常用于调试           |
|    `__getattr__(self, name)`     | 方法 | 在对象上查找指定名称的属性，如果找不到则引发AttributeError |
| `__setattr__(self, name, value)` | 方法 |                   设置对象的指定属性的值                   |
|    `__delattr__(self, name)`     | 方法 |                    从对象中删除指定属性                    |
|     `__getitem__(self, key)`     | 方法 |                       返回指定键的值                       |
| `__setitem__(self, key, value)`  | 方法 |                       设置指定键的值                       |
|     `__delitem__(self, key)`     | 方法 |                     从对象中删除指定键                     |
|         `__len__(self)`          | 方法 |                       返回对象的长度                       |
|         `__iter__(self)`         | 方法 |           返回一个迭代器对象，用于迭代对象的元素           |
|         `__next__(self)`         | 方法 |                   返回迭代器的下一个元素                   |
|    `__contains__(self, item)`    | 方法 |     如果对象包含指定的元素，则返回True，否则返回False      |
|      `__call__(self, ...)`       | 方法 |                     将对象作为函数调用                     |
|      `__add__(self, other)`      | 方法 |                        实现加法操作                        |
|      `__sub__(self, other)`      | 方法 |                        实现减法操作                        |
|      `__mul__(self, other)`      | 方法 |                        实现乘法操作                        |
|      `__div__(self, other)`      | 方法 |                        实现除法操作                        |
|      `__eq__(self, other)`       | 方法 |                    判断两个对象是否相等                    |
|      `__lt__(self, other)`       | 方法 |               判断一个对象是否小于另一个对象               |
|      `__gt__(self, other)`       | 方法 |               判断一个对象是否大于另一个对象               |
|      `__le__(self, other)`       | 方法 |             判断一个对象是否小于等于另一个对象             |
|      `__ge__(self, other)`       | 方法 |             判断一个对象是否大于等于另一个对象             |
|         `__bool__(self)`         | 方法 |           返回对象的布尔值，用于判断对象是否为真           |
|         `__hash__(self)`         | 方法 |                      返回对象的哈希值                      |
|         `__dir__(self)`          | 方法 |                     返回对象的属性列表                     |
|        `__class__(self)`         | 属性 |                      返回对象所属的类                      |
|         `__name__(self)`         | 属性 |                       返回对象的名称                       |
|        `__module__(self)`        | 属性 |                  返回对象所属的模块的名称                  |
|        `__bases__(self)`         | 属性 |                 返回对象所属的类的基类列表                 |

**方法中的self参数**

在Python中，方法中的self参数是一个约定俗成的名称，用于表示当前对象实例。它是在定义方法时自动传入的，表示方法被调用的对象实例本身。

使用self参数的好处是，它允许在方法中访问对象的属性和方法。通过self，方法可以访问并操作对象的状态和行为。这是面向对象编程的核心概念之一，因为它允许开发者将数据和行为封装在一个对象中，并提供对外的接口，从而实现更加模块化和可维护的代码。

- 在类的外部，通过变量名.访问对象的属性和方法；
- 在类封装的方法中，通过self.访问对象的属性和方法。

**初始化方法**

在Python中，类中的初始化方法是`__init__`，它是一个特殊的方法，用于在创建类的实例时初始化对象的状态。初始化方法通常用于为对象设置默认属性值或者执行其他必要的操作。

初始化方法的作用是在对象创建时进行初始化，即在对象实例化时自动调用。初始化方法可以接收任意数量的参数，但是第一个参数必须是self，表示该方法是对象实例的方法。除了self参数外，其他参数可以用于初始化对象的状态。

### 7.4 面向对象的封装

- 封装是面向对象编程的一大特点；
- 面向对象编程的第一步——将属性和方法封装到一个抽象的类中；
- 外界使用类创建对象，然后让对象调用方法；
- 对象方法的细节都被封装在类的内部。

**定义没有初始值的属性**

在定义属性时，如果不知道设置什么初始值，可以设置为None。

- None关键字表示什么都没有；
- 表示一个空对象，没有方法和属性，是一个特殊的常量；
- 可以将None赋值给任何一个变量。

**私有属性和方法**

在Python中，私有属性和方法是一种访问控制机制，用于保护类的内部实现细节，避免外部代码对其进行修改或者访问。私有属性和方法是通过在属性或方法名称前添加两个下划线"__"来定义的。

私有属性和方法的作用是将类的实现细节封装起来，避免外部代码对其进行非法访问或者修改。通过将属性和方法定义为私有的，我们可以确保它们只能在类的内部使用，从而保护类的数据完整性和安全性。

下面是一个示例，展示了如何在Python中定义私有属性和方法：

```python
class MyClass:
    def __init__(self):
        self.__private_attr = 0

    def __private_method(self):
        print("This is a private method")

    def public_method(self):
        self.__private_attr += 1
        self.__private_method()

obj = MyClass()
obj.public_method()
```

在上面的例子中，我们定义了一个名为`MyClass`的类，并在其中定义了一个私有属性`__private_attr`和一个私有方法`__private_method`。这两个属性和方法的名称前面都加上了两个下划线，表示它们是私有的，只能在类的内部使用。

在`__init__`方法中，我们为对象设置了一个私有属性`self.__private_attr`，初始值为0。在`public_method`方法中，我们对私有属性进行了修改，并调用了私有方法`__private_method`。

需要注意的是，尽管我们可以在类的内部访问和修改私有属性和方法，但是在类的外部却无法直接访问或者修改它们。如果我们在类的外部访问或者修改私有属性或方法，Python会抛出一个`AttributeError`异常。

虽然私有属性和方法在某些情况下很有用，但是需要注意的是，它们并不是一种绝对的访问控制机制。Python中的私有属性和方法只是一种约定，它们并不能完全防止外部代码对类进行访问或者修改。因此，在设计类时，应该根据具体情况来选择是否使用私有属性和方法，并慎重考虑其作用和影响。

在Python中，私有属性和方法是通过名称重整（name mangling）技术实现的。名称重整是一种将属性或方法名修改为带有类名前缀的方式，从而使它们在类的内部使用时能够被正常访问，但在类的外部访问时会被修改为其他名称，从而使其无法直接被访问。

具体来说，当我们在类中定义一个以两个下划线开头的属性或方法时，Python会将其重命名为 `_classname__attribute` 或 `_classname__method` 的形式。例如，如果我们在类中定义了一个私有属性`__private_attr`，它会被重命名为 `_MyClass__private_attr`。

这种方式确实可以在一定程度上保护属性和方法的访问权限，但它并不是一种绝对安全的机制。实际上，我们仍然可以通过一些技巧来访问或修改私有属性和方法。

首先，我们可以直接使用重命名后的名称来访问或者修改私有属性或方法，例如：

```python
class MyClass:
    def __init__(self):
        self.__private_attr = 0

obj = MyClass()
print(obj._MyClass__private_attr)  # 输出0
```

在上面的例子中，我们直接使用了重命名后的属性名称`_MyClass__private_attr`来访问私有属性，并成功地输出了属性的值0。

其次，我们还可以通过继承的方式来访问或者修改私有属性或方法。具体来说，如果一个子类继承了一个父类，它可以通过重写父类的方法来访问或者修改父类的私有属性或方法，例如：

```python
class MyClass:
    def __init__(self):
        self.__private_attr = 0

    def __private_method(self):
        print("This is a private method")

class MyChildClass(MyClass):
    def __init__(self):
        super().__init__()
        self.__private_attr = 1

obj = MyChildClass()
print(obj._MyClass__private_attr)  # 输出0
```

在上面的例子中，我们定义了一个名为`MyChildClass`的子类，它继承了`MyClass`类，并重写了`__init__`方法来修改父类的私有属性`__private_attr`。在访问`_MyClass__private_attr`时，它仍然输出了父类的属性值0，而不是子类中修改后的值1。

需要注意的是，虽然我们可以通过上述方式来访问或者修改私有属性或方法，但这并不是一个良好的编程实践。私有属性和方法应该被视为类的内部实现细节，应该尽量避免在类的外部访问或修改它们，以保证类的数据完整性和安全性。

### 7.5 面向对象的继承

- **子类**继承自**父类**，可以直接享受父类中已经封装好的方法，不需要再次开发；
- 子类中应该根据职责，封装子类特有的属性和方法；
- 继承具有传递性，子类拥有父类以及父类的父类中封装的所有属性和方法；
- 子类拥有父类的所有方法和属性。

**方法的重写**

- 子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发；
- 当父类的方法实现不能满足子类需求时，可以对方法进行重写。

重写父类方法有两种情况：一是，覆盖父类的方法；二是，对父类方法进行扩展。

:star:覆盖父类的方法

- 如果在开发中，父类的方法实现和子类的方法实现，完全不同就可以使用覆盖的方式，在子类中重新编写父类的方法实现。具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现。
- 重写之后，在运行时，只会调用子类中重写的方法，而不再调用父类封装的方法。

:star:对父类方法进行扩展

- 如果开发中，子类的方法实现中包含父类的方法实现，父类原本封装的方法实现是子类方法的一部分，就可以使用扩展的方式。
- 在子类中重写父类的方法，在需要的位置使用`super().父类方法`来调用父类方法的执行，代码其他的位置针对子类的需求，编写子类特有的代码实现。

**关于super**

- 在Python中super是一个特殊的类；
- super()就是使用super类创建出来的对象；
- 最常使用的场景就是在重写父类方法时，调佣在父类中封装的方法实现。

假设有一个汽车类 `Car`，它有一些基本的属性和方法，比如车牌号、颜色、品牌、加速、刹车等。现在我们要创建一个新的类 `ElectricCar`，它继承自 `Car` 类，但是具有一些额外的属性和方法，比如电池容量、充电时间、续航里程等。

下面是用 Python 代码实现这个例子的方式：

```python
class Car:
    def __init__(self, license_plate, color, brand):
        self.license_plate = license_plate
        self.color = color
        self.brand = brand
        self.speed = 0
    
    def accelerate(self, amount):
        self.speed += amount
        
    def brake(self, amount):
        self.speed -= amount

class ElectricCar(Car):
    def __init__(self, license_plate, color, brand, battery_capacity):
        super().__init__(license_plate, color, brand)
        self.battery_capacity = battery_capacity
        self.charge_time = 0
        self.range = 0
        
    def charge(self, amount):
        self.charge_time += amount
        
    def drive(self, distance):
        self.range += distance
```

在上面的例子中，`ElectricCar` 继承自 `Car`，它拥有 `Car` 类的所有属性和方法，同时也新增了 `charge` 和 `drive` 两个方法以及 `battery_capacity`、`charge_time`、`range` 三个属性。通过这种方式，我们可以避免重复编写代码，同时也可以通过继承和覆盖实现类的扩展和特殊化。

**父类的私有属性和私有方法**

- 子类对象不能在自己的方法内部，直接访问父类的私有属性或私有方法；
- 子类对象可以通过父类的公有方法间接访问到私有属性或者私有方法。
  - 私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问；
  - 私有属性、方法通常用于做一些内部的事情。

**多继承**

子类可以拥有多个父类，并且具有所有父类的属性和方法。

:star:MRO——方法搜索顺序

Python中针对类提供了一个内置属性`__mro__`可以查看方法搜索顺序。MRO(method resolution order)，主要用于在多继承时判断方法、属性的调用路径。

- 在搜索方法时，是按照`__mro__`的输出结果从左至右的顺序查找的；
- 如果在当前类中找到方法，就直接执行，不再搜索；
- 如果没有找到，就查找下一个类中是否有对应的方法，如果找到，就直接执行，不再搜索；
- 如果找到最后一个类，还没有找到方法，程序报错。

而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：

- 子类会先于父类被检查；
- 多个父类会根据它们在列表中的顺序被检查；
- 如果对下一个类存在两个合法的选择，选择第一个父类。

### 7.6 面向对象的多态

多态（Polymorphism）是面向对象编程中的一种重要特性，它允许不同的对象对同一个消息做出不同的响应。具体来说，多态是指通过使用父类或接口的引用来调用子类或具体实现类的方法，从而实现同一个行为有不同的表现形式。

在 Python 中，实现多态有多种方式，其中最常用的方式是方法重写（Overriding）。当子类继承了父类的方法时，如果子类需要改变该方法的实现方式，那么子类就可以重写该方法，并且在重写的方法中调用父类的方法，以实现基础功能的复用。这样，当父类的方法被调用时，子类的方法将被执行。

下面是一个简单的示例，其中 `Animal` 是父类，`Dog` 和 `Cat` 是子类。它们都重写了父类的 `make_sound` 方法，从而实现了不同的行为。

```python
class Animal:
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        print("汪汪汪！")

class Cat(Animal):
    def make_sound(self):
        print("喵喵喵！")
```

在上面的代码中，`Animal` 类定义了一个空的 `make_sound` 方法，而 `Dog` 和 `Cat` 类则分别重写了该方法并实现了自己的行为。当使用父类的引用调用 `make_sound` 方法时，它会根据实际引用的对象的类型来确定应该调用哪个子类的方法，从而实现了多态。

```python
def animal_sound(animal):
    animal.make_sound()

dog = Dog()
cat = Cat()

animal_sound(dog)  # 输出：汪汪汪！
animal_sound(cat)  # 输出：喵喵喵！
```

在上面的代码中，`animal_sound` 函数接受一个 `Animal` 类型的参数，并调用该参数的 `make_sound` 方法。当传入 `dog` 和 `cat` 对象时，分别输出它们的特定声音，这就是多态的体现。注意，`animal_sound` 函数并不知道传入的具体类型是哪个子类，但它可以正确地调用每个子类的方法。

### 7.7 类属性和类方法

**类的结构**

- 使用面向对象开发，第一步是设计类；
- 使用`类名()`创建对象，创建对象的动作有两步；
  - 在内存中为对象分配空间；
  - 调用初始化方法`__init__`为对象初始化。
- 对象创建后，内存中就有了一个对象的实实在在的存在——实例。

因此，通常也会把：

- 创建出来的对象叫做类的实例；
- 创建对象的动作叫做实例化；
- 对象的属性叫做实例属性；
- 对象调用的方法叫做实例方法。

在程序执行时：

- 对象各自拥有自己的实例属性；

- 调用对象方法，可以通过`self.`。

  - 访问自己的属性；

  - 调用自己的方法。

结论

- 每一个对象都有自己独立的内存空间，保存各自不同的属性；
- 多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部。

**类是一个特殊的对象**

Python中一切皆对象：

- `class Test:`定义的类属于类对象；
- `obj = Test()`属于实例对象；
- 在程序运行时，类同样会被加载到内存；
- 在Python中，类是一个特殊的对象——类对象；
- 在程序运行时，类对象在内存中只有一份，使用一个类可以创建出很多个对象实例；
- 除了封装实例的属性和方法外，类对象可以拥有自己的属性和方法；
  - 类属性
  - 类方法
- 通过`类名.`的方式可以访问类的属性或调用类的方法。

**类属性和实例属性**

- 类属性就是给类对象中定义的属性；
- 通常用来记录与这个类相关的特征；
- 类属性不会用于记录具体对象的特征；
- 在Python中属性的获取存在一个向上查找机制。

**类方法和静态方法**

:star:类方法

- 类方法是针对类对象定义的方法。在类方法内部可以直接访问类属性或者调用其他的类方法；
- 类方法需要用修饰器@classmethod来表示，告诉解释器这是一个类方法；
- 类方法的第一个参数应该是cls；
  - 由哪一个类调用的方法，方法内的cls就是哪一个类的引用；
  - 这个参数和实例方法的第一个参数是self类似；
  - 使用其他名称也可以，不过习惯使用cls。
- 通过`类名.`调用类方法，调用方法时，不需要传递cls参数；
- 在方法内部。
  - 可以通过`cls.`访问类的属性；
  - 也可以通过`cls.`调用群体的类方法。

类方法（Class Method）是一种定义在类中的方法，它被用来访问类的状态或者对类进行操作。类方法在调用时不需要实例化对象，而是通过类本身调用。在 Python 中，我们可以使用 `@classmethod` 装饰器来定义一个类方法。

下面是一个简单的示例，其中 `Person` 是一个人的类，它有一个 `count` 类变量和一个 `get_count` 类方法，用于记录和获取人的数量。

```python
class Person:
    count = 0

    def __init__(self, name):
        self.name = name
        Person.count += 1

    @classmethod
    def get_count(cls):
        return cls.count
```

在上面的代码中，`Person` 类包含一个 `count` 类变量，它记录创建的人的数量。当一个新的 `Person` 对象被创建时，`count` 变量会自增。`get_count` 类方法被用来获取当前已经创建的人的数量，它返回 `count` 变量的值。

```python
p1 = Person("Alice")
p2 = Person("Bob")
p3 = Person("Charlie")

print(Person.get_count())  # 输出：3
```

在上面的代码中，我们创建了三个 `Person` 对象，并调用了 `get_count` 类方法来获取已经创建的人的数量，它返回了 `3`。需要注意的是，我们调用 `get_count` 方法时并没有实例化 `Person` 类的任何对象，而是通过类本身调用该方法。这就是类方法的作用。

另外，需要注意的是，在类方法中可以访问类变量和调用类方法，但不能访问实例变量和实例方法。因为类方法是和类本身相关联的，而不是和类的某个具体实例相关联的。

:star:静态方法

- 在开发时，如果需要在类中封装一个方法，这个方法：
  - 既不需要访问实例属性或者调用实例方法；
  - 也不需要访问类属性或者调用类方法。
- 这个时候，可以把这个反复封装成一个静态方法。

静态方法（Static Method）是一种在类中定义的方法，它不需要访问实例属性或实例方法，也不需要访问类属性或类方法。静态方法在调用时既不需要实例化对象，也不需要通过类本身进行调用，它们通常用于执行一些与类相关但不依赖于类的操作。在 Python 中，我们可以使用 `@staticmethod` 装饰器来定义一个静态方法。

下面是一个简单的示例，其中 `Math` 是一个数学类，它包含一个静态方法 `add`，用于计算两个数的和。下面是一个简单的示例，其中 `Math` 是一个数学类，它包含一个静态方法 `add`，用于计算两个数的和。

```python
class Math:
    @staticmethod
    def add(x, y):
        return x + y
```

在上面的代码中，`Math` 类定义了一个静态方法 `add`，它接受两个参数 `x` 和 `y`，并返回它们的和。由于 `add` 方法不需要访问实例属性或实例方法，也不需要访问类属性或类方法，因此它可以被定义为一个静态方法。

```python
print(Math.add(1, 2))  # 输出：3
```

在上面的代码中，我们通过类本身调用了 `add` 静态方法，并传入两个参数 `1` 和 `2`，它返回了它们的和 `3`。需要注意的是，我们调用静态方法时既不需要实例化 `Math` 类的任何对象，也不需要通过实例对象进行调用，而是直接通过类本身调用该方法。这就是静态方法的作用。

另外，需要注意的是，在静态方法中不能访问实例变量、实例方法、类变量和类方法，因为静态方法不依赖于类或实例的状态，它们通常用于执行一些独立于类或实例的操作。

### 7.8 单例

**单例设计模式**

- 设计模式

  - 设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟的解决方案；

  - 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性，可扩展性良好。

- 单例设计模式

  - 目的——让类创建对象，在系统中只有唯一的一个实例；
  - 每一次执行类名()返回的对象，内存地址是相同的。

- 单例设计模式的应用场景

  - 回收站对象；
  - 音乐播放器对象；
  - 打印机对象；
  - ...

**`__new__`方法**

`__new__` 方法是 Python 中一个特殊的方法，用于创建一个对象，并返回这个对象的引用。它是 Python 中对象的创建过程中第一个被调用的方法，它通常是在 `__init__` 方法之前被调用。

- 使用类名()创建对象时，Python的解释器首先会调用`__new__`方法为对象分配空间；

- `__new__`是一个由object基类提供的内置的静态方法，主要作用有两个；

  - 在内存中为对象分配空间；

  - 返回对象的引用。

- Python的解释器获得对象的引用后，将引用作为第一个参数，传递给`__new__`方法；

- 重写`__new__`方法一定要`return super().__new__(cls)`，否则Python的解释器得不到分配空间的对象引用，就不会调用对象的初始化方法。

- `__new__`是一个静态方法，在调用时需要主动传递cls参数。

下面是一个简单的示例，其中 `Singleton` 是一个单例模式的类，它通过重写 `__new__` 方法来保证类只有一个实例。

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        print("Initializing Singleton instance")
```

在上面的代码中，`Singleton` 类定义了一个私有类变量 `_instance`，它用来存储类的唯一实例。在 `__new__` 方法中，我们首先检查 `_instance` 变量是否为空，如果为空，则通过调用父类的 `__new__` 方法来创建一个新的实例，并将其赋值给 `_instance` 变量。如果 `_instance` 变量不为空，则直接返回它所引用的实例。在 `__init__` 方法中，我们输出一条消息，以表明该类的实例已经被初始化。

```python
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出：True
```

在上面的代码中，我们创建了两个 `Singleton` 类的实例 `s1` 和 `s2`，并判断它们是否是同一个实例。由于 `Singleton` 类只有一个实例，因此 `s1` 和 `s2` 实际上是同一个实例，它们引用的是同一个对象。这就是通过重写 `__new__` 方法来实现单例模式的一个例子。

需要注意的是，`__new__` 方法是一个静态方法，它接受一个参数 `cls`，该参数表示要实例化的类。因此，在重写 `__new__` 方法时，需要使用 `cls` 参数来创建一个新的实例，而不是使用类名来创建实例。另外，`__new__` 方法在创建实例时需要返回实例的引用，如果不返回引用，则该类的实例将无法被创建。

**Python中的单例**

单例——让类创建的对象，在系统中只有唯一的一个实例。

- 定义一个类属性，初始值是None，用于记录单例对象的引用；
- 重写`__new__`方法；
- 如果类属性is None，调用父类方法分配空间，并在类属性中记录结果；
- 返回类属性中记录的对象引用；
- 只执行一次初始化操作。

```python
class MusicPlayer:
	# 记录第一个被创建对象的引用
	instance = None
	# 记录是否执行过初始化动作
	init_flag = False
	
	def __new__(cls, *args, **kwargs):
		# 判断类属性是否是空对象
		if cls.instance is None:
			# 调用父类的方法，为第一个对象分配空间
			cls.instance = super().__new__(cls)
		# 返回类属性保存的对象引用
		return cls.instance
	
	def __init__(self):
		if not MusicPlayer.init_flag:
			print("初始化音乐播放器")
			MusicPlayer.init_flag = True

# 创建多个对象
player1 = MusicPlayer()
player2 = MusicPlayer()

print(player1 is player2) # True
```

## 8 异常

### 8.1 异常的概念

> 程序开发时，很难将所有的特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件做集中的处理，从而保证程序的稳定性和健壮性。

- 程序在运行时，如果Python解释器遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常；
- 程序停止执行并且提示错误信息，这个动作称之为：抛出（raise）异常。

### 8.2 捕获异常

在Python中，我们可以使用try-except语句来捕获和处理异常，从而让程序在出现异常的情况下能够继续运行，而不会崩溃。

下面介绍几种常见的异常类型及其捕获方式：

**捕获所有异常**

有时候我们无法预知程序中会出现哪些异常，这时候可以使用except语句来捕获所有异常：

```python
try:
    # some code here
except:
    # handle the exception
```

在这个示例中，try语句块中包含需要执行的代码，如果代码中出现了任何异常，都会被except语句块捕获并处理。

**捕获指定类型的异常**

如果我们知道程序中可能出现哪些异常，可以针对这些异常类型使用except语句来捕获它们：

```python
try:
    # some code here
except ValueError:
    # handle ValueError
except KeyError:
    # handle KeyError
```

在这个示例中，如果try语句块中出现了ValueError异常，就会被第一个except语句块捕获并处理；如果出现了KeyError异常，就会被第二个except语句块捕获并处理。

**捕获多个异常类型**

我们也可以使用一个except语句块来捕获多个异常类型：

```python
try:
    # some code here
except (ValueError, KeyError):
    # handle ValueError or KeyError
```

在这个示例中，如果try语句块中出现了ValueError或KeyError异常，就会被except语句块捕获并处理。

**捕获异常并获取异常信息**

当程序出现异常时，我们可以通过except语句块来获取异常信息，以便更好地理解程序出现了什么问题：

```python
try:
    # some code here
except ValueError as e:
    print("ValueError:", e)
except KeyError as e:
    print("KeyError:", e)
```

在这个示例中，如果try语句块中出现了ValueError异常，就会被第一个except语句块捕获，并将异常信息存储在变量e中。我们可以使用print语句来输出异常信息。对于KeyError异常，也是同样的处理方式。

**捕获异常完整语法**

```python
try:
    # 代码块
except [异常类型1]:
    # 异常处理1
except [异常类型2]:
    # 异常处理2
...
except [异常类型n]:
    # 异常处理n
else:
    # 代码块没有抛出异常时执行
finally:
    # 总是会执行的代码块，不论有无异常发生
```

其中，`try`语句块中包含需要执行的代码。当代码块中出现了某个异常时，Python会查找和异常类型匹配的`except`语句块，并执行该语句块中的代码。如果代码块中没有抛出任何异常，Python会跳过所有的`except`语句块，执行`else`语句块中的代码；最后，不论是否发生了异常，Python都会执行`finally`语句块中的代码。

下面举一个简单的例子，说明Python中捕获异常的完整语法：

```python
try:
    x = int(input("请输入一个整数："))
    result = 10 / x
except ValueError:
    print("输入错误，请输入一个整数！")
except ZeroDivisionError:
    print("除数不能为0！")
else:
    print("计算结果：", result)
finally:
    print("程序执行完毕！")
```

Python 如何捕获异常发生的文件和具体行数呢？在Python中，我们可以通过`traceback`模块来获取异常发生的文件和行数。下面是一个示例，演示如何使用`traceback`模块来捕获异常并获取异常发生的文件和行数：

```python
try:
	print(a)
except Exception as e:
	print(e)
	print(e.__traceback__.tb_frame.f_globals["__file__"]) # 发生异常所在的文件
	print(e.__traceback__.tb_lineno) # 发生异常所在的行数
```

**异常的传递**

当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方，如果传递到主程序，仍然没有异常处理，程序才会被终止。因此，在开发中，可以在主函数中增加异常捕获。而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中。这样就不需要再代码中，增加大量的异常捕获，能够保证代码的简洁。

```python
def test():
	return int(input("输入整数："))

def main():
	return test()
	
# 利用异常的传递性，在主程序中捕获异常
try:
	print(main())
except Exception as e:
	print(f"未知错误 {e}")
```

**抛出（raise）异常**

Python中提供了一个Exception异常类，在开发时，如果满足特定业务需求时，希望抛出异常，可以创建一个Exception的对象，并使用raise关键字抛出异常对象。

下面是一个简单的例子，演示如何使用`raise`语句来抛出异常：

```python
def divide(x, y):
    if y == 0:
        raise ZeroDivisionError("除数不能为0！")
    return x / y

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print(e) # 除数不能为0！
```

在这个例子中，我们定义了一个`divide()`函数，用于计算两个数的商。如果除数为0，我们会使用`raise`语句抛出一个`ZeroDivisionError`异常，同时可以自定义异常信息（在这里是“除数不能为0！”）。在主程序中，我们尝试调用`divide()`函数来计算10除以0，这会引发一个`ZeroDivisionError`异常。当程序捕获到这个异常时，会将异常信息输出到控制台。

**assert语句**

在Python中，`assert`语句用于在程序中检查某个条件是否满足。如果条件不满足，则`assert`语句会抛出`AssertionError`异常，程序会停止执行。`assert`语句的语法如下：`assert expression [, arguments]`

其中，`expression`是需要检查的条件，如果这个条件为`False`，则`assert`语句会抛出`AssertionError`异常。`arguments`是可选的，用于指定抛出异常时的错误信息。

下面是一个使用`assert`语句的示例：

```python
def divide(x, y):
    assert y != 0, "除数不能为0"
    return x / y

print(divide(10, 2))  # 输出结果为 5.0
print(divide(10, 0))  # 抛出AssertionError异常，提示除数不能为0
```

在这个示例中，我们定义了一个`divide()`函数，用于计算两个数的商。在函数内部，我们使用`assert`语句检查除数是否为0，如果除数为0，则抛出`AssertionError`异常。在第一次调用`divide()`函数时，除数不为0，程序正常执行，输出结果为5.0；在第二次调用`divide()`函数时，除数为0，`assert`语句会抛出`AssertionError`异常，提示除数不能为0。

使用`assert`语句可以让我们在程序中快速检查某些条件是否满足，如果不满足则抛出异常。这样可以帮助我们更早地发现和解决问题。

## 9 模块和包

### 9.1 模块

模块是Python程序家口的一个核心概念，一个以扩展名py结尾的Python源代码文件都是一个模块。模块名同样也是一个标识符，需要符合标识符的命名规则。在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具。模块就好比是工具包，想要使用这个工具包中的工具，就需要先导入这个模块。

**模块的导入方式**

在Python中，我们可以使用两种方式导入模块，分别是：

- `import`语句：使用`import`语句导入一个模块，语法如下：

```python
import module_name
```

这种方式会将整个模块导入到当前程序中，并赋值给一个变量`module_name`，我们可以通过这个变量来访问模块中的函数、类、变量等。

- `from...import`语句：使用`from...import`语句从一个模块中导入指定的函数、类、变量等，语法如下：

```python
from module_name import name1, name2, ...
```

这种方式会将模块中指定的函数、类、变量等导入到当前程序中，并直接将它们的名字放入命名空间中，我们可以直接使用这些名字来访问它们。

如果我们想要导入模块中所有的函数、类、变量等，可以使用`*`通配符，语法如下：

```python
from module_name import *
```

不过，这种方式并不推荐使用，因为它可能会导致命名空间中出现重名的情况，从而引发命名冲突的问题。

两种方式各有优缺点，一般来说，如果我们只需要使用模块中的一部分功能，可以使用`from...import`语句来导入，这样可以减少代码量和命名空间的污染；如果我们需要使用模块中的大部分或全部功能，可以使用`import`语句来导入整个模块。

**模块的搜索顺序**

Python解释器在导入模块时，会搜索**当前目录**指定模块名的文件，如果有就直接导入。如果没有，再搜索系统目录。在开发时，给文件起名，不要和系统的模块文件重名。

Python中每一个模块都有一内置属性`__file__`可以查看模块的完整路径。

```python
import random

print(random.__file__)
rand = random.randint(0, 10)
print(rand)
```

**模块导入的原则**

- 每一个文件都应该是可以被导入的；
- 一个独立的Python文件就是一个模块；
- 在导入文件时，文件中所有没有任何缩进的代码都会被执行一遍。

### 9.2 包

包是一个包含多个模块的**特殊目录**，目录下有一个特殊文件`__init__.py`，包名的命名方式和变量名一致，小写字母+_。我们可以通过import包名一次性导入包中的所有模块。

`__init__.py`文件是Python中包的初始化文件，它的主要作用有以下几个：

- 初始化包的状态：我们可以在`__init__.py`文件中执行一些初始化操作，比如定义变量、导入模块、注册插件等，用于初始化包的状态。

```python
# __init__.py

# 定义一个变量
version = "1.0"

# 导入模块
from . import module1
from . import module2

# 注册插件
def register_plugin(plugin):
    pass

```

- 控制包的导入：在`__init__.py`文件中，我们可以通过代码控制包的导入行为，比如根据不同的条件导入不同的模块、根据平台选择不同的实现等。

```python
# __init__.py

import sys

# 根据平台选择实现
if sys.platform == "win32":
    from . import win32_impl as impl
else:
    from . import unix_impl as impl

# 导入默认的实现
from . import default_impl as default

# 导入接口
from .api import *
```

- 限制包的导入：在`__init__.py`文件中，我们可以通过代码限制包的导入行为，比如防止包被导入到不支持的平台、防止包被导入到不安全的环境等。

```python
# __init__.py

import os

# 检查是否在安全环境中运行
if os.environ.get("ENV") != "prod":
    raise RuntimeError("This package can only be used in production environment!")
```

- 提供包的接口：我们可以在`__init__.py`文件中定义包的接口，以便其他模块可以方便地使用包的功能。例如，我们可以在`__init__.py`文件中定义一个名为`__all__`的变量，来指定包中哪些模块、类、函数等是公开的，可以被其他模块直接使用。

```python
# __init__.py

__all__ = ["module1", "module2", "class1", "function1"]

# 导入模块
from . import module1
from . import module2

# 导入类和函数
from .module1 import Class1
from .module2 import function1
```

## 10 文件

### 10.1 文件的概念

- 计算机的**文件**就是存储在某种长期储存设备上的一段数据；
- 长期存储设备包括：硬盘、U盘、移动硬盘、光盘...
- 文件是用来将数据长期保存下来，并在需要的时候使用；
- 在计算机中，文件是以**二进制**的方式保存在磁盘上的。

**文件的类型**

- 文本文件
  - 可以使用文本编辑软件查看；
  - 本质上还是二进制文件。
- 二进制文件
  - 保存的内容不是给人直接阅读的，而是提供给其他软件使用的。例如：图片文件、音频文件、视频文件等；
  - 二进制文件不能使用文件编辑软件查看。

### 10.2 文件的基本操作

在计算机中操作文件一般包含三个步骤：

- 打开文件；
- 读、写文件；
  - 读 将文件内容读入内存
  - 写 将内容内容写入文件
- 关闭文件。

**操作文件的函数/方法**

| 序号 | 函数/方法 |             说明             |
| :--: | :-------: | :--------------------------: |
|  01  |   open    | 打开文件，并返回文件操作对象 |
|  02  |   read    |     将文件内容读取到内存     |
|  03  |   write   |      将指定内容写入文件      |
|  04  |   close   |           关闭文件           |

:star:read方法——读取文件

在 Python 中，我们可以使用 `open()` 函数来打开一个文件，并返回一个文件对象。文件对象提供了多种方法来读取、写入和管理文件。其中，`read()` 方法可以用来读取文件的内容。

`read()` 方法有一个可选参数 `size`，用于指定要读取的字节数。如果不指定 `size`，则会一次性读取整个文件的内容。

以下是一个读取文件的示例：

```python
# 打开文件
with open("example.txt", "r") as file:
    # 读取整个文件内容
    content = file.read()

# 输出文件内容
print(content)
```

如果文件过大，一次性读取整个文件可能会导致内存不足。此时，我们可以使用 `read(size)` 方法分多次读取文件的内容，每次读取指定字节数。

以下是一个分批读取文件的示例：

```python
# 打开文件
with open("example.txt", "r") as file:
    # 每次读取 10 个字节，直到文件末尾
    while True:
        content = file.read(10)
        if not content:
            break
        # 处理每一批读取的内容
        print(content)
```

在上面的代码中，我们每次读取 10 个字节的内容，如果文件到达末尾，则 `read()` 方法返回空字符串。通过 `while` 循环和判断语句，我们可以分批读取整个文件的内容。在每次读取一批内容后，我们可以对内容进行处理，比如输出到控制台、写入其他文件等。

:star:open方法——打开文件

在 Python 中，`open()` 函数用于打开文件，并返回一个文件对象。文件对象提供了多种方法来读取、写入和管理文件。`open()` 函数接受两个参数：文件名和打开模式。其中，打开模式包括读取模式、写入模式、追加模式等，具体模式如下：

|  模式  |                             说明                             |
| :----: | :----------------------------------------------------------: |
| `"r"`  |         读取模式，只能读取文件，不能修改或者写入文件         |
| `"w"`  |       写入模式，只能写入文件，如果文件不存在则创建文件       |
| `"x"`  |     排他模式，用于写入文件，如果文件已存在则无法创建文件     |
| `"a"`  |       追加模式，用于写入文件，如果文件不存在则创建文件       |
| `"b"`  |     二进制模式，用于处理二进制数据，如图片、音频、视频等     |
| `"t"`  |         文本模式，用于处理文本数据，如字符、字符串等         |
| `"+"`  |               读写模式，用于同时读取和写入文件               |
| `"r+"` | 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 |
| `"w+"` | 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
| `"a+"` | 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |

以下是打开文件的示例：

```python
# 以只读模式打开文件
file = open("example.txt", "r")
# 以写入模式打开文件，如果文件不存在则创建文件
file = open("example.txt", "w")
# 以追加模式打开文件，如果文件不存在则创建文件
file = open("example.txt", "a")
```

当我们成功打开一个文件后，就可以使用文件对象的方法来访问文件了。常用的文件访问方法包括：

| 方法            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| `read(size)`    | 读取指定字节数的内容                                         |
| `readline()`    | 读取一行内容                                                 |
| `readlines()`   | 读取所有行的内容，返回一个列表                               |
| `write(string)` | 将字符串写入文件                                             |
| `writelines()`  | 将多行字符串写入文件，参数是一个字符串列表，每个字符串代表一行 |

以下是以表格的形式展示不同的访问方式和说明：

| 方法                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `file.read()`                 | 读取整个文件的内容                                           |
| `file.read(n)`                | 读取前 n 个字符/字节的内容                                   |
| `file.readline()`             | 读取文件中的一行内容                                         |
| `file.readlines()`            | 读取文件中所有行的内容，返回列表                             |
| `file.write(s)`               | 将字符串 s 写入文件                                          |
| `file.writelines(lines)`      | 将字符串列表 lines 写入文件，每个字符串表示一行              |
| `file.seek(offset, whence=0)` | 将文件指针移动到指定位置。offset 表示相对于 whence 的偏移量，whence 的默认值是 0，即从文件开头开始计算偏移量。 |
| `file.tell()`                 | 返回当前文件指针的位置                                       |

使用这些方法，我们可以方便地读取和写入文件中的内容。下面是一些示例：

```python
# 以只读模式打开文件
file = open("example.txt", "r")
# 读取整个文件的内容
content = file.read()
print(content)
# 读取前10个字节的内容
content = file.read(10)
print(content)
# 读取文件的第一行
line = file.readline()
print(line)
# 读取所有行的内容
lines = file.readlines()
print(lines)
# 关闭文件
file.close()

# 以写入模式打开文件
file = open("example.txt", "w")
# 写入一行文本
file.write("Hello, world!")
# 关闭文件
file.close()

# 以追加模式打开文件
file = open("example.txt", "a")
# 写入多行文本
file.writelines(["This is the first line.\n", "This is the second line.\n"])
# 关闭文件
file.close()
```

在这个例子中，我们首先以只读模式打开了一个名为 `example.txt` 的文件，并使用 `read()` 方法读取了整个文件的内容。接着我们又使用 `read(10)` 方法只读取了前10个字节的内容，使用 `readline()` 方法读取了文件的第一行内容，使用 `readlines()` 方法读取了所有行的内容并返回一个列表。在写入文件方面，我们以写入模式打开文件，使用 `write()` 方法写入了一行文本，然后以追加模式打开文件，使用 `writelines()` 方法写入了多行文本。在每个操作完成之后，我们都调用了 `close()` 方法来关闭文件。

:star:seek的使用

在 Python 中，我们可以使用 `seek()` 方法改变当前文件的指针位置，以便读取或写入文件中的内容。`seek()` 方法的语法如下：

```python
file.seek(offset[, whence])
```

其中 `offset` 表示要移动的字节数，`whence` 表示从哪里开始移动。`whence` 的取值可以是以下几种：

- `0`：表示从文件开头开始计算。
- `1`：表示从当前位置开始计算。
- `2`：表示从文件末尾开始计算。

`whence` 参数可以省略，默认为 `0`。以下是一些示例：

```python
# 以只读模式打开文件
file = open("example.txt", "r")

# 读取文件的前5个字节
content = file.read(5)
print(content)

# 将文件指针移动到文件开头
file.seek(0)

# 读取文件的第一行
line = file.readline()
print(line)

# 将文件指针移动到文件末尾
file.seek(0, 2)

# 写入一行文本
file.write("This is a new line.")

# 关闭文件
file.close()
```

### 10.3 文件/目录的常用管理操作

在终端/文件浏览器中可以执行常规的文件/目录管理操作，例如：创建、重命名、删除、改变路径、查看目录内容…… 但在Python中，如果希望通过程序实现上述功能，需要导入 os 模块。

**文件操作**

| 序号 |        方法名         |                             说明                             |                    示例                     |
| :--: | :-------------------: | :----------------------------------------------------------: | :-----------------------------------------: |
|  1   | `os.rename(src, dst)` | 重命名文件，将原文件名 `src` 修改为新文件名 `dst`。如果 `dst` 已经存在，则会抛出 `FileExistsError` 异常。 | `os.rename('old_name.txt', 'new_name.txt')` |
|  2   |   `os.remove(path)`   | 删除指定路径下的文件。如果文件不存在或没有删除权限，则会抛出 `FileNotFoundError` 或 `PermissionError` 异常。 |           `os.remove('file.txt')`           |

**目录操作**

| 序号 |       方法名       |          说明          |                     示例                      |
| :--: | :----------------: | :--------------------: | :-------------------------------------------: |
|  1   |    `os.mkdir()`    |        创建目录        |           `os.mkdir('example_dir')`           |
|  2   |    `os.rmdir()`    |        删除目录        |           `os.rmdir('example_dir')`           |
|  3   |   `os.listdir()`   |    列出目录中的文件    |           `files = os.listdir('.')`           |
|  4   |   `os.rename()`    |    重命名文件或目录    | `os.rename('example.txt', 'new_example.txt')` |
|  5   |   `os.remove()`    |        删除文件        |          `os.remove('example.txt')`           |
|  6   | `os.path.exists()` | 判断文件或目录是否存在 |    `if os.path.exists('example.txt'): ...`    |
|  7   | `os.path.isfile()` |     判断是否是文件     |    `if os.path.isfile('example.txt'): ...`    |
|  8   | `os.path.isdir()`  |     判断是否是目录     |    `if os.path.isdir('example_dir'): ...`     |

这些操作包括了常见的文件和目录的创建、删除、重命名、读取和写入等操作，也包括了判断文件和目录是否存在，以及判断给定的路径是文件还是目录等操作。其中 `os` 模块提供了许多有用的文件和目录操作函数。当然，这里只是列出了一些常见的操作，实际上还有很多其他的操作，具体使用时需要查阅文档。
