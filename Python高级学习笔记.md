# Python高级学习笔记

Abstract：本文主要记录了作者在日常学习Python过程中所掌握的一些高级功能特性，例如正则表达式、装饰器等内容，并对其进行了总结和归纳。

Author： Duguce

Email：zhgyqc@163.com

Datetime:  2022-03-21 20:40 —— 2022-03-23 22:39

## 1 正则表达式

> 正则表达式是一种用于匹配、搜索、替换文本的工具。正则表达式通常由一些特殊字符和常规字符组成，可以用来表示文本模式。

正则表达式通常用于文本处理任务，如搜索、替换、解析和验证文本。它们可以被用于各种编程语言和工具中，如Perl、Python、Java、JavaScript、sed、grep、awk等等。

正则表达式可以用于：

- 匹配一个文本模式，如匹配一个特定的字符串。
- 匹配一组字符串，如匹配所有以特定字符串开头的字符串。
- 匹配一些字符集合，如匹配所有数字或所有字母。
- 替换文本中的一个模式，如将所有特定字符串替换为另一个字符串。
- 分割文本，如将一个长字符串分割成一组短字符串。
- 验证文本，如检查一个字符串是否符合特定的格式要求。

### 1.1 re模块简介

在 Python 中，可以使用内置模块 `re` 来进行正则表达式的操作。

常用的函数有：

- `re.search(pattern, string)`：在字符串 `string` 中搜索匹配正则表达式 `pattern` 的第一个位置，并返回一个包含匹配信息的 `Match` 对象，如果匹配不成功，则返回 `None`。
- `re.match(pattern, string)`：从字符串 `string` 的起始位置开始匹配正则表达式 `pattern`，如果匹配成功，则返回一个包含匹配信息的 `Match` 对象，否则返回 `None`。
- `re.findall(pattern, string)`：搜索字符串 `string` 中所有匹配正则表达式 `pattern` 的子串，并返回一个列表，如果没有匹配成功，则返回空列表。
- `re.sub(pattern, repl, string)`：在字符串 `string` 中搜索匹配正则表达式 `pattern` 的所有子串，并用 `repl` 替换掉，返回替换后的字符串。
- `re.search(pattern, string, flags=0)`：`search`函数会在字符串 `string` 中从左到右搜索，找到第一个与正则表达式匹配的位置。如果在字符串中找不到匹配项，则返回`None`。

### 1.2 匹配单个字符

| 字符 |                功能                |
| :--: | :--------------------------------: |
| `.`  |    匹配除了换行符以外的任意字符    |
| `[]` |         匹配[]中列举的字符         |
| `\w` |       匹配字母、数字、下划线       |
| `\d` |              匹配数字              |
| `\s` | 匹配空格、制表符、换行符等空白字符 |
| `\W` |   匹配非字母、数字、下划线的字符   |
| `\D` |          匹配非数字的字符          |
| `\S` |           匹配非空白字符           |

### 1.3 匹配多个字符

|  字符   |                功能                |
| :-----: | :--------------------------------: |
|   `*`   |   匹配前面的字符或组合零次或多次   |
|   `+`   |   匹配前面的字符或组合一次或多次   |
|   `?`   |   匹配前面的字符或组合零次或一次   |
|  `{m}`  | 匹配前面的字符或组合恰好出现 m 次  |
| `{m,}`  | 匹配前面的字符或组合至少出现 m 次  |
| `{m,n}` | 匹配前面的字符或组合出现 m 到 n 次 |

例如，`*` 字符可以匹配前面的字符或组合出现零次或多次，如 `r"a*"` 可以匹配零个或多个 `a` 字符。`+` 字符可以匹配前面的字符或组合出现一次或多次，如 `r"a+"` 可以匹配至少一个 `a` 字符。`?` 字符可以匹配前面的字符或组合出现零次或一次，如 `r"a?"` 可以匹配零个或一个 `a` 字符。`{m}`、`{m,}` 和 `{m,n}` 则可以用来匹配特定数量的字符或组合。

另外需要注意的是，以上匹配多个字符的字符通常都是贪婪匹配，即会尽可能多地匹配字符。例如，对于字符串 `"aaaa"`，使用 `r"a*"` 进行匹配时会匹配整个字符串，而不是只匹配一个 `a`。如果想要进行非贪婪匹配，可以在这些字符后面添加一个 `?`，例如，`r"a*?"` 可以进行非贪婪匹配。

### 1.4 匹配开头结尾

| 字符 |                             功能                             |
| :--: | :----------------------------------------------------------: |
| `^`  |                       匹配字符串的开头                       |
| `$`  |                       匹配字符串的结尾                       |
| `\A` | 匹配字符串的开头（与 `^` 的区别在于，`\A` 不会匹配多行字符串的每一行的开头） |
| `\Z` | 匹配字符串的结尾（与 `$` 的区别在于，`\Z` 不会匹配多行字符串的每一行的结尾） |
| `\b` |           匹配单词边界，即单词与非单词字符的交界处           |
| `\B` |                        匹配非单词边界                        |

### 1.5 匹配分组

|    字符     |                            功能                            |
| :---------: | :--------------------------------------------------------: |
|     ()      |      匹配并捕获括号内的表达式，将匹配结果保存在分组中      |
|    (?:)     |         匹配但不捕获括号内的表达式，不保存匹配结果         |
| (?P\<name>) | 匹配并捕获括号内的表达式，将匹配结果保存在指定名称的分组中 |
|  (?P=name)  |           匹配与之前指定名称的分组匹配的相同文本           |
|    (?#)     |              注释，不影响正则表达式的匹配结果              |

其中，匹配并捕获括号内的表达式的语法为 `()`，例如 `(hello)` 会匹配并捕获字符串中的 `hello`，将其保存在分组中。可以通过数字来引用分组，例如 `\1` 引用第一个分组的匹配结果。如果需要匹配但不捕获括号内的表达式，则可以使用 `(?:)`，例如 `(?:hello)` 只会匹配 `hello`，但不会将其保存在分组中。

如果希望将匹配结果保存在指定名称的分组中，可以使用 `(?P<name>)` 的语法，例如 `(?P<name>hello)` 会将 `hello` 保存在名为 `name` 的分组中。可以通过 `(?P=name)` 来引用指定名称的分组匹配的相同文本。

最后，如果需要在正则表达式中添加注释，可以使用 `(?#)`，例如 `(?#This is a comment)hello` 不会匹配任何内容，但不会影响正则表达式的匹配结果。

### 1.6 贪婪与非贪婪匹配

在正则表达式中，贪婪匹配和非贪婪匹配是指匹配操作对待重复匹配符号（如星号和加号）的不同处理方式。

贪婪匹配指的是尽可能多地匹配字符串，也就是匹配到最后一个匹配符号为止。例如，对于正则表达式 `a.*b`，当匹配字符串 `aabab` 时，贪婪匹配会匹配整个字符串 `aabab`，而不是只匹配 `aab`。

非贪婪匹配（也称为懒惰匹配或最小匹配）指的是尽可能少地匹配字符串，也就是在第一个匹配符号处停止匹配。例如，对于正则表达式 `a.*?b`，当匹配字符串 `aabab` 时，非贪婪匹配会匹配 `aab`，而不是整个字符串 `aabab`。

在正则表达式中，可以通过在匹配符号后添加问号来实现非贪婪匹配，例如，`*?` 表示匹配零个或多个字符（非贪婪匹配），而 `*` 表示匹配零个或多个字符（贪婪匹配）。

## 2 GIL

> GIL（Global Interpreter Lock）是在Python解释器中使用的一种锁机制，它是为了保证线程安全而存在的。

在Python中，解释器的内存管理不是线程安全的，这意味着当多个线程同时访问共享内存时，可能会出现数据竞争的情况。为了避免这种情况，Python引入了GIL锁。

GIL锁的作用是在同一时刻只有一个线程能够执行Python字节码，这保证了Python解释器的线程安全。换句话说，GIL锁会在任意时刻只允许一个线程执行Python解释器中的字节码。

虽然GIL锁能够保证线程安全，但同时也会带来一些限制。由于同一时刻只能有一个线程执行Python字节码，所以多线程的性能可能会受到影响。特别是当线程需要执行CPU密集型任务时，由于GIL锁的存在，多线程并不能带来多核CPU的优势。

需要注意的是，GIL锁只存在于CPython解释器中。在使用Jython、IronPython、PyPy等其他Python解释器时，可能不存在GIL锁或者GIL锁的实现方式不同。

## 3 深浅拷贝

在Python中，拷贝一个对象可以使用赋值、浅拷贝和深拷贝等方式。其中，浅拷贝和深拷贝是最常用的两种拷贝方式。

- **赋值**操作是最简单的一种拷贝方式，**只是将对象的引用复制给一个新的变量**，新变量和原对象指向**同一块内存地址**。因此，如果修改其中一个变量的值，另一个变量的值也会发生改变。
- **浅拷贝**是指**创建一个新对象**，其中**包含原对象中的所有元素**的副本。对于不可变类型（例如数字、字符串、元组等），浅拷贝会创建一个全新的对象。**对于可变类型**（例如列表、字典等），浅拷贝**只会拷贝对象的引用**，而不是对象本身。这意味着，如果修改浅拷贝后的对象中的可变类型元素，原对象中对应的元素也会发生改变。

浅拷贝可以使用Python内置的copy模块中的copy()函数实现。

- **深拷贝**是指**创建一个新对象**，其中**包含原对象中所有元素的完整拷贝**。无论元素是不可变类型还是可变类型，都会创建一个全新的对象。因此，修改深拷贝后的对象不会影响原对象。

深拷贝可以使用Python内置的copy模块中的deepcopy()函数实现。需要注意的是，深拷贝可能会比浅拷贝慢，因为需要创建完整的副本。此外，如果对象包含嵌套的对象，深拷贝可能会导致递归的拷贝过程，消耗更多的内存和计算资源。

```python
a = [1, 2, 3]
b = a
b.append(4)
print(a)  # 输出 [1, 2, 3, 4]
-----------------------------------------------
import copy

a = [1, [2, 3]]
b = copy.copy(a)
b[0] = 4
b[1].append(4)
print(a)  # 输出 [1, [2, 3, 4]]
-----------------------------------------------
import copy

a = [1, [2, 3]]
b = copy.deepcopy(a)
b[0] = 4
b[1].append(4)
print(a)  # 输出 [1, [2, 3]]
```

